import { z } from 'zod';
import { promises as fs } from 'fs';
import { join, dirname } from 'path';
import { execSync } from 'child_process';
import {
  Transformation,
  ConsequenceRecord,
  ObservationEvent,
  GuardrailResult,
  Artifact,
  ToolCall,
  CoreProtectionResult,
  RecorderConfig,
  TransformationSchema,
  ConsequenceRecordSchema,
  RecorderConfigSchema,
} from '../../src/types/agent-observability';
import { CoreProtection } from './CoreProtection';

export interface TransformationSink {
  write(record: ConsequenceRecord): Promise<void>;
}

export class FileSystemSink implements TransformationSink {
  constructor(private basePath: string) {}

  async write(record: ConsequenceRecord): Promise<void> {
    const patchDir = join(this.basePath, 'docs', 'patches', `patch-${record.transformation.patchId}`);
    
    // Ensure directory exists
    await fs.mkdir(patchDir, { recursive: true });
    
    // Write JSONL ledger entry
    const ledgerPath = join(patchDir, 'ledger.jsonl');
    const ledgerEntry = JSON.stringify(record) + '\n';
    await fs.appendFile(ledgerPath, ledgerEntry, 'utf8');
    
    // Write human-readable consequences
    const consequencesPath = join(patchDir, 'CONSEQUENCES.md');
    const markdown = this.generateConsequencesMarkdown(record);
    await fs.writeFile(consequencesPath, markdown, 'utf8');
  }

  private generateConsequencesMarkdown(record: ConsequenceRecord): string {
    const { transformation, guardrails, summary, decision, coreIntegrityVerified } = record;
    
    const passedGuardrails = guardrails.filter(g => g.status === 'pass');
    const failedGuardrails = guardrails.filter(g => g.status === 'fail');
    const warningGuardrails = guardrails.filter(g => g.status === 'warn');
    
    return `# Transformation Consequences - Patch ${transformation.patchId}

**Transformation ID**: \`${transformation.id}\`  
**Branch**: \`${transformation.branch}\`  
**Timestamp**: ${transformation.timestamp}  
**Core Integrity**: ${coreIntegrityVerified ? 'âœ… VERIFIED' : 'âŒ COMPROMISED'}  
**Decision**: **${decision.toUpperCase()}**

## Summary

${summary}

## Files Modified

${transformation.filesTouched.map(f => `- \`${f}\``).join('\n')}

## Git Statistics

- **Additions**: ${transformation.gitStats.additions}
- **Deletions**: ${transformation.gitStats.deletions}
- **Changed Files**: ${transformation.gitStats.changedFiles}
- **SHA**: \`${transformation.gitStats.sha}\`

## Core Protection Status

**Status**: \`${transformation.coreProtectionStatus}\`

${transformation.coreProtectionStatus === 'violation_detected' ? 
  'âš ï¸ **WARNING**: Pristine core violation detected but blocked by protection mechanisms.' : 
  transformation.coreProtectionStatus === 'violation_blocked' ?
  'ðŸ›‘ **CRITICAL**: Attempted pristine core modification was blocked.' :
  'âœ… No pristine core violations detected.'
}

## Guardrail Results

### âœ… Passed (${passedGuardrails.length})
${passedGuardrails.map(g => `- **${g.name}**: ${Object.entries(g.metrics).map(([k,v]) => `${k}=${v}`).join(', ')}`).join('\n')}

${failedGuardrails.length > 0 ? `### âŒ Failed (${failedGuardrails.length})
${failedGuardrails.map(g => `- **${g.name}**: ${Object.entries(g.metrics).map(([k,v]) => `${k}=${v}`).join(', ')}`).join('\n')}` : ''}

${warningGuardrails.length > 0 ? `### âš ï¸ Warnings (${warningGuardrails.length})
${warningGuardrails.map(g => `- **${g.name}**: ${Object.entries(g.metrics).map(([k,v]) => `${k}=${v}`).join(', ')}`).join('\n')}` : ''}

## Learning Insights

${record.learningInsights?.length ? 
  record.learningInsights.map(insight => `- ${insight}`).join('\n') : 
  'No adaptive learning insights recorded.'
}

---
*Generated by TransformationRecorder v${record.version}*
`;
  }
}

export class SupabaseSink implements TransformationSink {
  constructor(private supabaseClient: any) {}

  async write(record: ConsequenceRecord): Promise<void> {
    // Transform to database schema
    const transformationRow = {
      id: record.transformation.id,
      patch_id: record.transformation.patchId,
      batch_id: record.transformation.batchId || null,
      branch: record.transformation.branch,
      author_id: record.transformation.authorId,
      created_at: record.transformation.timestamp,
      categories: record.transformation.categories,
      files_touched: record.transformation.filesTouched,
      git_stats: record.transformation.gitStats,
      core_protection_status: record.transformation.coreProtectionStatus,
      summary: record.summary,
      decision: record.decision,
      core_integrity_verified: record.coreIntegrityVerified,
    };

    // Insert transformation
    const { error: transformationError } = await this.supabaseClient
      .from('transformations')
      .insert(transformationRow);

    if (transformationError) {
      throw new Error(`Failed to insert transformation: ${transformationError.message}`);
    }

    // Insert guardrails
    const guardrailRows = record.guardrails.map(g => ({
      id: `${record.transformation.id}-${g.name}`,
      transformation_id: record.transformation.id,
      name: g.name,
      status: g.status,
      created_at: g.timestamp,
      duration: g.duration,
      metrics: g.metrics,
      exit_code: g.exitCode || null,
    }));

    if (guardrailRows.length > 0) {
      const { error: guardrailError } = await this.supabaseClient
        .from('guardrails')
        .insert(guardrailRows);

      if (guardrailError) {
        throw new Error(`Failed to insert guardrails: ${guardrailError.message}`);
      }
    }

    // Insert artifacts
    const artifactRows = record.artifacts.map(a => ({
      id: a.id,
      transformation_id: record.transformation.id,
      kind: a.kind,
      path: a.path,
      hash: a.hash || null,
      size: a.size || null,
      metadata: a.metadata || null,
      created_at: new Date().toISOString(),
    }));

    if (artifactRows.length > 0) {
      const { error: artifactError } = await this.supabaseClient
        .from('artifacts')
        .insert(artifactRows);

      if (artifactError) {
        throw new Error(`Failed to insert artifacts: ${artifactError.message}`);
      }
    }
  }
}

export class TransformationRecorder {
  private transformation: Transformation | null = null;
  private events: ObservationEvent[] = [];
  private guardrails: GuardrailResult[] = [];
  private artifacts: Artifact[] = [];
  private toolCalls: ToolCall[] = [];
  private sinks: TransformationSink[] = [];
  private coreProtection: CoreProtection;

  constructor(private config: RecorderConfig) {
    this.config = RecorderConfigSchema.parse(config);
    this.coreProtection = new CoreProtection(config);
    
    // Initialize sinks
    if (config.enableFileSystemSink) {
      this.sinks.push(new FileSystemSink(process.cwd()));
    }
    
    if (config.enableSupabaseSink && process.env.SUPABASE_CLIENT) {
      // Note: Supabase client would be injected in real implementation
      // this.sinks.push(new SupabaseSink(supabaseClient));
    }
  }

  async start(context: {
    patchId: number;
    batchId?: number;
    branch: string;
    authorId: string;
    filesTouched: string[];
  }): Promise<string> {
    // Validate core protection BEFORE starting
    const coreProtectionResult = await this.coreProtection.validateTransformation(context.filesTouched);
    
    if (!coreProtectionResult.isValid && coreProtectionResult.violations.some(v => v.severity === 'critical')) {
      throw new Error(`CRITICAL: Pristine core violation detected. Cannot proceed with transformation.`);
    }

    // Get git information
    const gitStats = this.getGitStats();
    const transformationId = `patch-${context.patchId}@${gitStats.sha.substring(0, 7)}`;

    this.transformation = TransformationSchema.parse({
      id: transformationId,
      patchId: context.patchId,
      batchId: context.batchId,
      branch: context.branch,
      authorId: context.authorId,
      timestamp: new Date().toISOString(),
      categories: this.categorizeFiles(context.filesTouched),
      filesTouched: context.filesTouched,
      gitStats,
      coreProtectionStatus: coreProtectionResult.isValid ? 'safe' : 'violation_detected',
    });

    // Record start event
    await this.attachEvent({
      name: 'transformation_started',
      timestamp: new Date().toISOString(),
      severity: 'info',
      payload: { transformationId, filesTouched: context.filesTouched },
      category: 'system',
    });

    return transformationId;
  }

  async attachEvent(event: ObservationEvent): Promise<void> {
    this.events.push(event);
  }

  async attachArtifact(artifact: Artifact): Promise<void> {
    this.artifacts.push(artifact);
  }

  async attachToolCall(toolCall: ToolCall): Promise<void> {
    // Validate tool call against core protection if enabled
    if (this.config.enableCoreProtection && toolCall.name === 'Edit') {
      const filePath = toolCall.parameters.file_path as string;
      if (filePath && this.coreProtection.isPristineCorePath(filePath)) {
        toolCall.coreProtectionCheck = true;
        await this.attachEvent({
          name: 'core_protection_violation',
          timestamp: new Date().toISOString(),
          severity: 'critical',
          payload: { toolCall: toolCall.name, filePath },
          category: 'core_protection',
        });
      }
    }
    
    this.toolCalls.push(toolCall);
  }

  async finalize(summary: string, decision: 'proceed' | 'fix_required' | 'rollback' | 'manual_review'): Promise<ConsequenceRecord> {
    if (!this.transformation) {
      throw new Error('Cannot finalize: transformation not started');
    }

    // Run all guardrails
    await this.runGuardrails();

    // Final core integrity check
    const finalCoreCheck = await this.coreProtection.auditCoreIntegrity();
    const coreIntegrityVerified = finalCoreCheck.isValid;

    // Generate learning insights
    const learningInsights = this.generateLearningInsights();

    const record: ConsequenceRecord = ConsequenceRecordSchema.parse({
      transformation: this.transformation,
      events: this.events,
      guardrails: this.guardrails,
      artifacts: this.artifacts,
      toolCalls: this.toolCalls,
      summary,
      decision,
      coreIntegrityVerified,
      learningInsights,
      redactions: this.config.redactPatterns,
      version: '1.0',
    });

    // Write to all sinks
    for (const sink of this.sinks) {
      await sink.write(record);
    }

    // Record completion event
    await this.attachEvent({
      name: 'transformation_completed',
      timestamp: new Date().toISOString(),
      severity: 'info',
      payload: { decision, coreIntegrityVerified },
      category: 'system',
    });

    return record;
  }

  private async runGuardrails(): Promise<void> {
    const guardrailRunners = [
      () => this.runTypecheck(),
      () => this.runLint(),
      () => this.runTests(),
      () => this.runBuild(),
      () => this.runCoreProtection(),
    ];

    for (const runner of guardrailRunners) {
      try {
        const result = await runner();
        this.guardrails.push(result);
      } catch (error) {
        // Continue with other guardrails even if one fails
        console.warn(`Guardrail failed: ${error}`);
      }
    }
  }

  private async runTypecheck(): Promise<GuardrailResult> {
    const start = Date.now();
    try {
      const output = execSync('pnpm typecheck', { encoding: 'utf8', timeout: 30000 });
      return {
        name: 'typecheck',
        status: 'pass',
        timestamp: new Date().toISOString(),
        duration: Date.now() - start,
        metrics: { errors: 0 },
        artifacts: [],
        exitCode: 0,
        stdout: output,
      };
    } catch (error: any) {
      return {
        name: 'typecheck',
        status: 'fail',
        timestamp: new Date().toISOString(),
        duration: Date.now() - start,
        metrics: { errors: 1 },
        artifacts: [],
        exitCode: error.status || 1,
        stderr: error.message,
      };
    }
  }

  private async runLint(): Promise<GuardrailResult> {
    const start = Date.now();
    try {
      const output = execSync('pnpm lint', { encoding: 'utf8', timeout: 30000 });
      return {
        name: 'lint',
        status: 'pass',
        timestamp: new Date().toISOString(),
        duration: Date.now() - start,
        metrics: { errors: 0, warnings: 0 },
        artifacts: [],
        exitCode: 0,
        stdout: output,
      };
    } catch (error: any) {
      return {
        name: 'lint',
        status: 'fail',
        timestamp: new Date().toISOString(),
        duration: Date.now() - start,
        metrics: { errors: 1 },
        artifacts: [],
        exitCode: error.status || 1,
        stderr: error.message,
      };
    }
  }

  private async runTests(): Promise<GuardrailResult> {
    const start = Date.now();
    try {
      const output = execSync('pnpm test --coverage --passWithNoTests', { encoding: 'utf8', timeout: 60000 });
      // Parse coverage from output (simplified)
      const coverageMatch = output.match(/All files[^|]*\|[^|]*\|[^|]*\|[^|]*\|[^|]*(\d+\.?\d*)/);
      const coverage = coverageMatch ? parseFloat(coverageMatch[1]) : 0;
      
      return {
        name: 'test',
        status: coverage >= 90 ? 'pass' : 'warn',
        timestamp: new Date().toISOString(),
        duration: Date.now() - start,
        metrics: { coverage, passed: 1, failed: 0 },
        artifacts: ['coverage/lcov-report/index.html'],
        exitCode: 0,
        stdout: output,
      };
    } catch (error: any) {
      return {
        name: 'test',
        status: 'fail',
        timestamp: new Date().toISOString(),
        duration: Date.now() - start,
        metrics: { coverage: 0, passed: 0, failed: 1 },
        artifacts: [],
        exitCode: error.status || 1,
        stderr: error.message,
      };
    }
  }

  private async runBuild(): Promise<GuardrailResult> {
    const start = Date.now();
    try {
      const output = execSync('pnpm build', { encoding: 'utf8', timeout: 120000 });
      return {
        name: 'build',
        status: 'pass',
        timestamp: new Date().toISOString(),
        duration: Date.now() - start,
        metrics: { success: true },
        artifacts: ['.next/build-manifest.json'],
        exitCode: 0,
        stdout: output,
      };
    } catch (error: any) {
      return {
        name: 'build',
        status: 'fail',
        timestamp: new Date().toISOString(),
        duration: Date.now() - start,
        metrics: { success: false },
        artifacts: [],
        exitCode: error.status || 1,
        stderr: error.message,
      };
    }
  }

  private async runCoreProtection(): Promise<GuardrailResult> {
    const start = Date.now();
    const result = await this.coreProtection.auditCoreIntegrity();
    
    return {
      name: 'core_protection',
      status: result.isValid ? 'pass' : 'fail',
      timestamp: new Date().toISOString(),
      duration: Date.now() - start,
      metrics: { 
        violations: result.violations.length,
        protectedPaths: result.protectedPaths.length,
        allowedPaths: result.allowedPaths.length,
      },
      artifacts: [],
    };
  }

  private getGitStats() {
    try {
      const sha = execSync('git rev-parse HEAD', { encoding: 'utf8' }).trim();
      const stats = execSync('git diff --stat HEAD~1', { encoding: 'utf8' });
      
      // Parse git diff stats (simplified)
      const lines = stats.split('\n');
      const summaryLine = lines[lines.length - 2] || '';
      const match = summaryLine.match(/(\d+) files? changed(?:, (\d+) insertions?)?(?:, (\d+) deletions?)?/);
      
      return {
        sha,
        additions: match ? parseInt(match[2] || '0') : 0,
        deletions: match ? parseInt(match[3] || '0') : 0,
        changedFiles: match ? parseInt(match[1]) : 0,
      };
    } catch {
      return {
        sha: 'unknown',
        additions: 0,
        deletions: 0,
        changedFiles: 0,
      };
    }
  }

  private categorizeFiles(files: string[]): Array<'code' | 'config' | 'database' | 'infrastructure' | 'docs'> {
    const categories = new Set<'code' | 'config' | 'database' | 'infrastructure' | 'docs'>();
    
    for (const file of files) {
      if (file.match(/\.(ts|tsx|js|jsx)$/)) categories.add('code');
      if (file.match(/\.(json|yaml|yml|env|config)$/)) categories.add('config');
      if (file.match(/prisma|migrations|\.sql$/)) categories.add('database');
      if (file.match(/\.github|docker|vercel|\.config\./)) categories.add('infrastructure');
      if (file.match(/\.md$|docs\//)) categories.add('docs');
    }
    
    return Array.from(categories);
  }

  private generateLearningInsights(): string[] {
    const insights: string[] = [];
    
    // Analyze guardrail patterns
    const failedGuardrails = this.guardrails.filter(g => g.status === 'fail');
    if (failedGuardrails.length > 0) {
      insights.push(`Failed guardrails: ${failedGuardrails.map(g => g.name).join(', ')}`);
    }
    
    // Analyze file patterns
    if (this.transformation) {
      const fileTypes = this.transformation.filesTouched.map(f => f.split('.').pop()).filter(Boolean);
      const uniqueTypes = [...new Set(fileTypes)];
      insights.push(`File types modified: ${uniqueTypes.join(', ')}`);
    }
    
    // Analyze tool usage
    const toolNames = [...new Set(this.toolCalls.map(t => t.name))];
    if (toolNames.length > 0) {
      insights.push(`Tools used: ${toolNames.join(', ')}`);
    }
    
    return insights;
  }
}
