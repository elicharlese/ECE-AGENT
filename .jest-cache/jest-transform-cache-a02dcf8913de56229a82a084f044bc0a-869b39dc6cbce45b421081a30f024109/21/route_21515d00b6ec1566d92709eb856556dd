97ac50317f2fa76c3f447a51eeb3de83
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get DELETE () {
        return DELETE;
    },
    get GET () {
        return GET;
    },
    get POST () {
        return POST;
    },
    get runtime () {
        return runtime;
    }
});
const _server = require("next/server");
const runtime = 'nodejs';
const REMOTE_MCP_URL = 'https://api.githubcopilot.com/mcp/';
function getPat(req) {
    const pat = req.headers.get('x-github-pat') || req.headers.get('authorization');
    if (!pat) return null;
    return pat.startsWith('Bearer ') ? pat : `Bearer ${pat}`;
}
async function POST(req) {
    try {
        const pat = getPat(req);
        if (!pat) {
            return _server.NextResponse.json({
                error: 'Missing GitHub PAT or Authorization header'
            }, {
                status: 400
            });
        }
        const body = await req.text();
        const upstream = await fetch(REMOTE_MCP_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                Authorization: pat,
                // Forward session if provided by client
                ...req.headers.get('mcp-session-id') ? {
                    'Mcp-Session-Id': String(req.headers.get('mcp-session-id'))
                } : {}
            },
            body: body || '{}'
        });
        const text = await upstream.text();
        const headers = new Headers();
        headers.set('Content-Type', upstream.headers.get('content-type') || 'application/json');
        const upstreamSessionId = upstream.headers.get('Mcp-Session-Id');
        if (upstreamSessionId) headers.set('Mcp-Session-Id', upstreamSessionId);
        headers.set('Access-Control-Expose-Headers', 'Mcp-Session-Id');
        return new _server.NextResponse(text, {
            status: upstream.status,
            headers
        });
    } catch (err) {
        console.error('MCP proxy POST error:', err);
        return _server.NextResponse.json({
            error: 'MCP proxy POST failed'
        }, {
            status: 500
        });
    }
}
async function GET(req) {
    try {
        const pat = getPat(req);
        const sessionId = req.headers.get('mcp-session-id');
        if (!pat) {
            return _server.NextResponse.json({
                error: 'Missing GitHub PAT or Authorization header'
            }, {
                status: 400
            });
        }
        if (!sessionId) {
            return _server.NextResponse.json({
                error: 'Missing Mcp-Session-Id header'
            }, {
                status: 400
            });
        }
        const upstream = await fetch(REMOTE_MCP_URL, {
            method: 'GET',
            headers: {
                Authorization: pat,
                'Mcp-Session-Id': sessionId
            }
        });
        const headers = new Headers();
        headers.set('Content-Type', upstream.headers.get('content-type') || 'text/event-stream');
        headers.set('Cache-Control', 'no-cache');
        headers.set('Connection', 'keep-alive');
        headers.set('Access-Control-Expose-Headers', 'Mcp-Session-Id');
        const upstreamSessionId = upstream.headers.get('Mcp-Session-Id');
        if (upstreamSessionId) headers.set('Mcp-Session-Id', upstreamSessionId);
        if (!upstream.body) {
            return new _server.NextResponse('Upstream returned no body', {
                status: 502
            });
        }
        // Pass-through streaming body
        return new Response(upstream.body, {
            status: upstream.status,
            headers
        });
    } catch (err) {
        console.error('MCP proxy GET error:', err);
        return new _server.NextResponse('MCP proxy GET failed', {
            status: 500
        });
    }
}
async function DELETE(req) {
    try {
        const pat = getPat(req);
        const sessionId = req.headers.get('mcp-session-id');
        if (!pat || !sessionId) {
            return _server.NextResponse.json({
                error: 'Missing credentials or session id'
            }, {
                status: 400
            });
        }
        const upstream = await fetch(REMOTE_MCP_URL, {
            method: 'DELETE',
            headers: {
                Authorization: pat,
                'Mcp-Session-Id': sessionId
            }
        });
        const text = await upstream.text();
        const headers = new Headers();
        headers.set('Content-Type', upstream.headers.get('content-type') || 'application/json');
        headers.set('Access-Control-Expose-Headers', 'Mcp-Session-Id');
        return new _server.NextResponse(text, {
            status: upstream.status,
            headers
        });
    } catch (err) {
        console.error('MCP proxy DELETE error:', err);
        return _server.NextResponse.json({
            error: 'MCP proxy DELETE failed'
        }, {
            status: 500
        });
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbGljaGFybGVzZS9DYXNjYWRlUHJvamVjdHMvRUNFLUFHRU5UL2FwcC9hcGkvbWNwL2dpdGh1Yi9yb3V0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0UmVxdWVzdCwgTmV4dFJlc3BvbnNlIH0gZnJvbSAnbmV4dC9zZXJ2ZXInXG5cbmV4cG9ydCBjb25zdCBydW50aW1lID0gJ25vZGVqcydcblxuY29uc3QgUkVNT1RFX01DUF9VUkwgPSAnaHR0cHM6Ly9hcGkuZ2l0aHViY29waWxvdC5jb20vbWNwLydcblxuZnVuY3Rpb24gZ2V0UGF0KHJlcTogTmV4dFJlcXVlc3QpOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgcGF0ID0gcmVxLmhlYWRlcnMuZ2V0KCd4LWdpdGh1Yi1wYXQnKSB8fCByZXEuaGVhZGVycy5nZXQoJ2F1dGhvcml6YXRpb24nKVxuICBpZiAoIXBhdCkgcmV0dXJuIG51bGxcbiAgcmV0dXJuIHBhdC5zdGFydHNXaXRoKCdCZWFyZXIgJykgPyBwYXQgOiBgQmVhcmVyICR7cGF0fWBcbn1cblxuLy8gUE9TVCDigJMgaW5pdGlhbGl6ZSBvciBzZW5kIHJlcXVlc3Qgb3ZlciBNQ1AgSFRUUFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIFBPU1QocmVxOiBOZXh0UmVxdWVzdCk6IFByb21pc2U8TmV4dFJlc3BvbnNlPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGF0ID0gZ2V0UGF0KHJlcSlcbiAgICBpZiAoIXBhdCkge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6ICdNaXNzaW5nIEdpdEh1YiBQQVQgb3IgQXV0aG9yaXphdGlvbiBoZWFkZXInIH0sIHsgc3RhdHVzOiA0MDAgfSlcbiAgICB9XG5cbiAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVxLnRleHQoKVxuXG4gICAgY29uc3QgdXBzdHJlYW0gPSBhd2FpdCBmZXRjaChSRU1PVEVfTUNQX1VSTCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIEF1dGhvcml6YXRpb246IHBhdCxcbiAgICAgICAgLy8gRm9yd2FyZCBzZXNzaW9uIGlmIHByb3ZpZGVkIGJ5IGNsaWVudFxuICAgICAgICAuLi4ocmVxLmhlYWRlcnMuZ2V0KCdtY3Atc2Vzc2lvbi1pZCcpXG4gICAgICAgICAgPyB7ICdNY3AtU2Vzc2lvbi1JZCc6IFN0cmluZyhyZXEuaGVhZGVycy5nZXQoJ21jcC1zZXNzaW9uLWlkJykpIH1cbiAgICAgICAgICA6IHt9KSxcbiAgICAgIH0sXG4gICAgICBib2R5OiBib2R5IHx8ICd7fScsXG4gICAgfSlcblxuICAgIGNvbnN0IHRleHQgPSBhd2FpdCB1cHN0cmVhbS50ZXh0KClcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKVxuICAgIGhlYWRlcnMuc2V0KCdDb250ZW50LVR5cGUnLCB1cHN0cmVhbS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgfHwgJ2FwcGxpY2F0aW9uL2pzb24nKVxuICAgIGNvbnN0IHVwc3RyZWFtU2Vzc2lvbklkID0gdXBzdHJlYW0uaGVhZGVycy5nZXQoJ01jcC1TZXNzaW9uLUlkJylcbiAgICBpZiAodXBzdHJlYW1TZXNzaW9uSWQpIGhlYWRlcnMuc2V0KCdNY3AtU2Vzc2lvbi1JZCcsIHVwc3RyZWFtU2Vzc2lvbklkKVxuICAgIGhlYWRlcnMuc2V0KCdBY2Nlc3MtQ29udHJvbC1FeHBvc2UtSGVhZGVycycsICdNY3AtU2Vzc2lvbi1JZCcpXG5cbiAgICByZXR1cm4gbmV3IE5leHRSZXNwb25zZSh0ZXh0LCB7IHN0YXR1czogdXBzdHJlYW0uc3RhdHVzLCBoZWFkZXJzIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ01DUCBwcm94eSBQT1NUIGVycm9yOicsIGVycilcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogJ01DUCBwcm94eSBQT1NUIGZhaWxlZCcgfSwgeyBzdGF0dXM6IDUwMCB9KVxuICB9XG59XG5cbi8vIEdFVCDigJMgc3RyZWFtIFNTRSBub3RpZmljYXRpb25zXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gR0VUKHJlcTogTmV4dFJlcXVlc3QpOiBQcm9taXNlPFJlc3BvbnNlPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGF0ID0gZ2V0UGF0KHJlcSlcbiAgICBjb25zdCBzZXNzaW9uSWQgPSByZXEuaGVhZGVycy5nZXQoJ21jcC1zZXNzaW9uLWlkJylcblxuICAgIGlmICghcGF0KSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBlcnJvcjogJ01pc3NpbmcgR2l0SHViIFBBVCBvciBBdXRob3JpemF0aW9uIGhlYWRlcicgfSwgeyBzdGF0dXM6IDQwMCB9KVxuICAgIH1cbiAgICBpZiAoIXNlc3Npb25JZCkge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6ICdNaXNzaW5nIE1jcC1TZXNzaW9uLUlkIGhlYWRlcicgfSwgeyBzdGF0dXM6IDQwMCB9KVxuICAgIH1cblxuICAgIGNvbnN0IHVwc3RyZWFtID0gYXdhaXQgZmV0Y2goUkVNT1RFX01DUF9VUkwsIHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIEF1dGhvcml6YXRpb246IHBhdCxcbiAgICAgICAgJ01jcC1TZXNzaW9uLUlkJzogc2Vzc2lvbklkLFxuICAgICAgfSxcbiAgICB9KVxuXG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKClcbiAgICBoZWFkZXJzLnNldCgnQ29udGVudC1UeXBlJywgdXBzdHJlYW0uaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpIHx8ICd0ZXh0L2V2ZW50LXN0cmVhbScpXG4gICAgaGVhZGVycy5zZXQoJ0NhY2hlLUNvbnRyb2wnLCAnbm8tY2FjaGUnKVxuICAgIGhlYWRlcnMuc2V0KCdDb25uZWN0aW9uJywgJ2tlZXAtYWxpdmUnKVxuICAgIGhlYWRlcnMuc2V0KCdBY2Nlc3MtQ29udHJvbC1FeHBvc2UtSGVhZGVycycsICdNY3AtU2Vzc2lvbi1JZCcpXG4gICAgY29uc3QgdXBzdHJlYW1TZXNzaW9uSWQgPSB1cHN0cmVhbS5oZWFkZXJzLmdldCgnTWNwLVNlc3Npb24tSWQnKVxuICAgIGlmICh1cHN0cmVhbVNlc3Npb25JZCkgaGVhZGVycy5zZXQoJ01jcC1TZXNzaW9uLUlkJywgdXBzdHJlYW1TZXNzaW9uSWQpXG5cbiAgICBpZiAoIXVwc3RyZWFtLmJvZHkpIHtcbiAgICAgIHJldHVybiBuZXcgTmV4dFJlc3BvbnNlKCdVcHN0cmVhbSByZXR1cm5lZCBubyBib2R5JywgeyBzdGF0dXM6IDUwMiB9KVxuICAgIH1cblxuICAgIC8vIFBhc3MtdGhyb3VnaCBzdHJlYW1pbmcgYm9keVxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UodXBzdHJlYW0uYm9keSwgeyBzdGF0dXM6IHVwc3RyZWFtLnN0YXR1cywgaGVhZGVycyB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKCdNQ1AgcHJveHkgR0VUIGVycm9yOicsIGVycilcbiAgICByZXR1cm4gbmV3IE5leHRSZXNwb25zZSgnTUNQIHByb3h5IEdFVCBmYWlsZWQnLCB7IHN0YXR1czogNTAwIH0pXG4gIH1cbn1cblxuLy8gREVMRVRFIOKAkyB0ZXJtaW5hdGUgc2Vzc2lvbiB1cHN0cmVhbVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIERFTEVURShyZXE6IE5leHRSZXF1ZXN0KTogUHJvbWlzZTxOZXh0UmVzcG9uc2U+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXQgPSBnZXRQYXQocmVxKVxuICAgIGNvbnN0IHNlc3Npb25JZCA9IHJlcS5oZWFkZXJzLmdldCgnbWNwLXNlc3Npb24taWQnKVxuXG4gICAgaWYgKCFwYXQgfHwgIXNlc3Npb25JZCkge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6ICdNaXNzaW5nIGNyZWRlbnRpYWxzIG9yIHNlc3Npb24gaWQnIH0sIHsgc3RhdHVzOiA0MDAgfSlcbiAgICB9XG5cbiAgICBjb25zdCB1cHN0cmVhbSA9IGF3YWl0IGZldGNoKFJFTU9URV9NQ1BfVVJMLCB7XG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBdXRob3JpemF0aW9uOiBwYXQsXG4gICAgICAgICdNY3AtU2Vzc2lvbi1JZCc6IHNlc3Npb25JZCxcbiAgICAgIH0sXG4gICAgfSlcblxuICAgIGNvbnN0IHRleHQgPSBhd2FpdCB1cHN0cmVhbS50ZXh0KClcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKVxuICAgIGhlYWRlcnMuc2V0KCdDb250ZW50LVR5cGUnLCB1cHN0cmVhbS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgfHwgJ2FwcGxpY2F0aW9uL2pzb24nKVxuICAgIGhlYWRlcnMuc2V0KCdBY2Nlc3MtQ29udHJvbC1FeHBvc2UtSGVhZGVycycsICdNY3AtU2Vzc2lvbi1JZCcpXG5cbiAgICByZXR1cm4gbmV3IE5leHRSZXNwb25zZSh0ZXh0LCB7IHN0YXR1czogdXBzdHJlYW0uc3RhdHVzLCBoZWFkZXJzIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ01DUCBwcm94eSBERUxFVEUgZXJyb3I6JywgZXJyKVxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGVycm9yOiAnTUNQIHByb3h5IERFTEVURSBmYWlsZWQnIH0sIHsgc3RhdHVzOiA1MDAgfSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkRFTEVURSIsIkdFVCIsIlBPU1QiLCJydW50aW1lIiwiUkVNT1RFX01DUF9VUkwiLCJnZXRQYXQiLCJyZXEiLCJwYXQiLCJoZWFkZXJzIiwiZ2V0Iiwic3RhcnRzV2l0aCIsIk5leHRSZXNwb25zZSIsImpzb24iLCJlcnJvciIsInN0YXR1cyIsImJvZHkiLCJ0ZXh0IiwidXBzdHJlYW0iLCJmZXRjaCIsIm1ldGhvZCIsIkF1dGhvcml6YXRpb24iLCJTdHJpbmciLCJIZWFkZXJzIiwic2V0IiwidXBzdHJlYW1TZXNzaW9uSWQiLCJlcnIiLCJjb25zb2xlIiwic2Vzc2lvbklkIiwiUmVzcG9uc2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O1FBMkZzQkE7ZUFBQUE7O1FBekNBQztlQUFBQTs7UUFyQ0FDO2VBQUFBOztRQVhUQztlQUFBQTs7O3dCQUY2QjtBQUVuQyxNQUFNQSxVQUFVO0FBRXZCLE1BQU1DLGlCQUFpQjtBQUV2QixTQUFTQyxPQUFPQyxHQUFnQjtJQUM5QixNQUFNQyxNQUFNRCxJQUFJRSxPQUFPLENBQUNDLEdBQUcsQ0FBQyxtQkFBbUJILElBQUlFLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDO0lBQy9ELElBQUksQ0FBQ0YsS0FBSyxPQUFPO0lBQ2pCLE9BQU9BLElBQUlHLFVBQVUsQ0FBQyxhQUFhSCxNQUFNLENBQUMsT0FBTyxFQUFFQSxLQUFLO0FBQzFEO0FBR08sZUFBZUwsS0FBS0ksR0FBZ0I7SUFDekMsSUFBSTtRQUNGLE1BQU1DLE1BQU1GLE9BQU9DO1FBQ25CLElBQUksQ0FBQ0MsS0FBSztZQUNSLE9BQU9JLG9CQUFZLENBQUNDLElBQUksQ0FBQztnQkFBRUMsT0FBTztZQUE2QyxHQUFHO2dCQUFFQyxRQUFRO1lBQUk7UUFDbEc7UUFFQSxNQUFNQyxPQUFPLE1BQU1ULElBQUlVLElBQUk7UUFFM0IsTUFBTUMsV0FBVyxNQUFNQyxNQUFNZCxnQkFBZ0I7WUFDM0NlLFFBQVE7WUFDUlgsU0FBUztnQkFDUCxnQkFBZ0I7Z0JBQ2hCWSxlQUFlYjtnQkFDZix3Q0FBd0M7Z0JBQ3hDLEdBQUlELElBQUlFLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLG9CQUNoQjtvQkFBRSxrQkFBa0JZLE9BQU9mLElBQUlFLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDO2dCQUFtQixJQUM5RCxDQUFDLENBQUM7WUFDUjtZQUNBTSxNQUFNQSxRQUFRO1FBQ2hCO1FBRUEsTUFBTUMsT0FBTyxNQUFNQyxTQUFTRCxJQUFJO1FBQ2hDLE1BQU1S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