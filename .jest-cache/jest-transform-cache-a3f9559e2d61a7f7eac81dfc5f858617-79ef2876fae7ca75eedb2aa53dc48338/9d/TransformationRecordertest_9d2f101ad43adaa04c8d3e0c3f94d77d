24908eb0d88109a37fd03b3c66ffb5af
"use strict";
// Mock dependencies
jest.mock("fs", ()=>({
        promises: {
            mkdir: jest.fn(),
            appendFile: jest.fn(),
            writeFile: jest.fn()
        }
    }));
jest.mock("child_process", ()=>({
        execSync: jest.fn()
    }));
jest.mock("../../libs/observability/CoreProtection");
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _TransformationRecorder = require("../../libs/observability/TransformationRecorder");
const _CoreProtection = require("../../libs/observability/CoreProtection");
const _fs = require("fs");
const _child_process = require("child_process");
describe("TransformationRecorder", ()=>{
    let recorder;
    let mockConfig;
    let mockCoreProtection;
    beforeEach(()=>{
        mockConfig = {
            enableFileSystemSink: true,
            enableSupabaseSink: false,
            enableCoreProtection: true,
            redactPatterns: [
                ".env*",
                "*secret*"
            ],
            protectedPaths: [
                "src/types/agent.ts"
            ],
            learningPaths: [
                "docs/patches/**"
            ]
        };
        mockCoreProtection = {
            validateTransformation: jest.fn(),
            auditCoreIntegrity: jest.fn(),
            isPristineCorePath: jest.fn(),
            isLearningLayerPath: jest.fn(),
            enforceProtection: jest.fn(),
            generateProtectionReport: jest.fn()
        };
        _CoreProtection.CoreProtection.mockImplementation(()=>mockCoreProtection);
        recorder = new _TransformationRecorder.TransformationRecorder(mockConfig);
    });
    describe("start", ()=>{
        beforeEach(()=>{
            mockCoreProtection.validateTransformation.mockResolvedValue({
                isValid: true,
                violations: [],
                protectedPaths: [],
                allowedPaths: [
                    "components/chat/chat-window.tsx"
                ],
                timestamp: new Date().toISOString()
            });
            _child_process.execSync.mockReturnValue("abc123def\n");
        });
        it("should start transformation recording successfully", async ()=>{
            const context = {
                patchId: 1,
                branch: "main",
                authorId: "user-123",
                filesTouched: [
                    "components/chat/chat-window.tsx"
                ]
            };
            const transformationId = await recorder.start(context);
            expect(transformationId).toMatch(/^patch-1@[a-f0-9]{7}$/);
            expect(mockCoreProtection.validateTransformation).toHaveBeenCalledWith(context.filesTouched);
        });
        it("should throw error for critical core violations", async ()=>{
            mockCoreProtection.validateTransformation.mockResolvedValue({
                isValid: false,
                violations: [
                    {
                        path: "src/types/agent.ts",
                        reason: "Pristine core violation",
                        severity: "critical"
                    }
                ],
                protectedPaths: [
                    "src/types/agent.ts"
                ],
                allowedPaths: [],
                timestamp: new Date().toISOString()
            });
            const context = {
                patchId: 1,
                branch: "main",
                authorId: "user-123",
                filesTouched: [
                    "src/types/agent.ts"
                ]
            };
            await expect(recorder.start(context)).rejects.toThrow("CRITICAL: Pristine core violation detected");
        });
        it("should allow non-critical violations", async ()=>{
            mockCoreProtection.validateTransformation.mockResolvedValue({
                isValid: false,
                violations: [
                    {
                        path: "some-file.ts",
                        reason: "Minor violation",
                        severity: "warning"
                    }
                ],
                protectedPaths: [],
                allowedPaths: [
                    "some-file.ts"
                ],
                timestamp: new Date().toISOString()
            });
            const context = {
                patchId: 1,
                branch: "main",
                authorId: "user-123",
                filesTouched: [
                    "some-file.ts"
                ]
            };
            const transformationId = await recorder.start(context);
            expect(transformationId).toBeDefined();
        });
    });
    describe("attachToolCall", ()=>{
        beforeEach(async ()=>{
            mockCoreProtection.validateTransformation.mockResolvedValue({
                isValid: true,
                violations: [],
                protectedPaths: [],
                allowedPaths: [
                    "test.tsx"
                ],
                timestamp: new Date().toISOString()
            });
            _child_process.execSync.mockReturnValue("abc123def\n");
            await recorder.start({
                patchId: 1,
                branch: "main",
                authorId: "user-123",
                filesTouched: [
                    "test.tsx"
                ]
            });
        });
        it("should record tool calls normally", async ()=>{
            const toolCall = {
                id: "tool-1",
                name: "Read",
                timestamp: new Date().toISOString(),
                parameters: {
                    file_path: "test.tsx"
                },
                duration: 100,
                coreProtectionCheck: false
            };
            await recorder.attachToolCall(toolCall);
        // No exception should be thrown
        });
        it("should detect core protection violations in Edit tool calls", async ()=>{
            mockCoreProtection.isPristineCorePath.mockReturnValue(true);
            const toolCall = {
                id: "tool-1",
                name: "Edit",
                timestamp: new Date().toISOString(),
                parameters: {
                    file_path: "src/types/agent.ts"
                },
                duration: 100,
                coreProtectionCheck: false
            };
            await recorder.attachToolCall(toolCall);
            expect(mockCoreProtection.isPristineCorePath).toHaveBeenCalledWith("src/types/agent.ts");
            expect(toolCall.coreProtectionCheck).toBe(true);
        });
    });
    describe("finalize", ()=>{
        beforeEach(async ()=>{
            mockCoreProtection.validateTransformation.mockResolvedValue({
                isValid: true,
                violations: [],
                protectedPaths: [],
                allowedPaths: [
                    "test.tsx"
                ],
                timestamp: new Date().toISOString()
            });
            mockCoreProtection.auditCoreIntegrity.mockResolvedValue({
                isValid: true,
                violations: [],
                protectedPaths: [],
                allowedPaths: [],
                timestamp: new Date().toISOString()
            });
            _child_process.execSync.mockReturnValueOnce("abc123def\n") // git rev-parse HEAD
            .mockReturnValueOnce("") // typecheck
            .mockReturnValueOnce("") // lint
            .mockReturnValueOnce("All files | 95.2 |") // test coverage
            .mockReturnValueOnce(""); // build
            await recorder.start({
                patchId: 1,
                branch: "main",
                authorId: "user-123",
                filesTouched: [
                    "test.tsx"
                ]
            });
        });
        it("should finalize transformation with all guardrails", async ()=>{
            const record = await recorder.finalize("Test transformation", "proceed");
            expect(record.transformation.id).toMatch(/^patch-1@[a-f0-9]{7}$/);
            expect(record.summary).toBe("Test transformation");
            expect(record.decision).toBe("proceed");
            expect(record.coreIntegrityVerified).toBe(true);
            expect(record.guardrails).toHaveLength(5); // typecheck, lint, test, build, core_protection
        });
        it("should handle guardrail failures gracefully", async ()=>{
            _child_process.execSync.mockReturnValueOnce("abc123def\n") // git rev-parse HEAD (for start)
            .mockImplementationOnce(()=>{
                const error = new Error("Type error");
                error.status = 1;
                throw error;
            });
            const record = await recorder.finalize("Test with failures", "fix_required");
            expect(record.decision).toBe("fix_required");
            expect(record.guardrails.some((g)=>g.name === "typecheck" && g.status === "fail")).toBe(true);
        });
        it("should generate learning insights", async ()=>{
            await recorder.attachToolCall({
                id: "tool-1",
                name: "Edit",
                timestamp: new Date().toISOString(),
                parameters: {
                    file_path: "test.tsx"
                },
                duration: 100,
                coreProtectionCheck: false
            });
            const record = await recorder.finalize("Test insights", "proceed");
            expect(record.learningInsights).toBeDefined();
            expect(record.learningInsights.length).toBeGreaterThan(0);
            expect(record.learningInsights.some((insight)=>insight.includes("Tools used: Edit"))).toBe(true);
        });
    });
    describe("FileSystemSink", ()=>{
        let sink;
        let mockRecord;
        beforeEach(()=>{
            sink = new _TransformationRecorder.FileSystemSink("/test/base/path");
            mockRecord = {
                transformation: {
                    id: "patch-1@abc123",
                    patchId: 1,
                    branch: "main",
                    authorId: "user-123",
                    timestamp: new Date().toISOString(),
                    categories: [
                        "code"
                    ],
                    filesTouched: [
                        "test.tsx"
                    ],
                    gitStats: {
                        sha: "abc123def",
                        additions: 10,
                        deletions: 5,
                        changedFiles: 1
                    },
                    coreProtectionStatus: "safe"
                },
                events: [],
                guardrails: [
                    {
                        name: "typecheck",
                        status: "pass",
                        timestamp: new Date().toISOString(),
                        duration: 1000,
                        metrics: {
                            errors: 0
                        },
                        artifacts: []
                    }
                ],
                artifacts: [],
                toolCalls: [],
                summary: "Test transformation",
                decision: "proceed",
                coreIntegrityVerified: true,
                version: "1.0"
            };
        });
        it("should write JSONL ledger and markdown consequences", async ()=>{
            await sink.write(mockRecord);
            expect(_fs.promises.mkdir).toHaveBeenCalledWith("/test/base/path/docs/patches/patch-1", {
                recursive: true
            });
            expect(_fs.promises.appendFile).toHaveBeenCalledWith("/test/base/path/docs/patches/patch-1/ledger.jsonl", expect.stringContaining('"id":"patch-1@abc123"'), "utf8");
            expect(_fs.promises.writeFile).toHaveBeenCalledWith("/test/base/path/docs/patches/patch-1/CONSEQUENCES.md", expect.stringContaining("# Transformation Consequences - Patch 1"), "utf8");
        });
        it("should generate comprehensive markdown report", async ()=>{
            mockRecord.guardrails.push({
                name: "test",
                status: "fail",
                timestamp: new Date().toISOString(),
                duration: 2000,
                metrics: {
                    passed: 0,
                    failed: 1
                },
                artifacts: []
            });
            await sink.write(mockRecord);
            const markdownCall = _fs.promises.writeFile.mock.calls.find((call)=>call[0].endsWith("CONSEQUENCES.md"));
            const markdown = markdownCall[1];
            expect(markdown).toContain("**Core Integrity**: ✅ VERIFIED");
            expect(markdown).toContain("**Decision**: **PROCEED**");
            expect(markdown).toContain("### ✅ Passed (1)");
            expect(markdown).toContain("### ❌ Failed (1)");
            expect(markdown).toContain("- `test.tsx`");
        });
    });
    afterEach(()=>{
        jest.clearAllMocks();
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbGljaGFybGVzZS9DYXNjYWRlUHJvamVjdHMvQUdFTlQvX190ZXN0c19fL29ic2VydmFiaWxpdHkvVHJhbnNmb3JtYXRpb25SZWNvcmRlci50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRyYW5zZm9ybWF0aW9uUmVjb3JkZXIsIEZpbGVTeXN0ZW1TaW5rIH0gZnJvbSAnLi4vLi4vbGlicy9vYnNlcnZhYmlsaXR5L1RyYW5zZm9ybWF0aW9uUmVjb3JkZXInO1xuaW1wb3J0IHsgQ29yZVByb3RlY3Rpb24gfSBmcm9tICcuLi8uLi9saWJzL29ic2VydmFiaWxpdHkvQ29yZVByb3RlY3Rpb24nO1xuaW1wb3J0IHsgUmVjb3JkZXJDb25maWcsIENvbnNlcXVlbmNlUmVjb3JkIH0gZnJvbSAnLi4vLi4vc3JjL3R5cGVzL2FnZW50LW9ic2VydmFiaWxpdHknO1xuaW1wb3J0IHsgcHJvbWlzZXMgYXMgZnMgfSBmcm9tICdmcyc7XG5pbXBvcnQgeyBleGVjU3luYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuXG4vLyBNb2NrIGRlcGVuZGVuY2llc1xuamVzdC5tb2NrKCdmcycsICgpID0+ICh7XG4gIHByb21pc2VzOiB7XG4gICAgbWtkaXI6IGplc3QuZm4oKSxcbiAgICBhcHBlbmRGaWxlOiBqZXN0LmZuKCksXG4gICAgd3JpdGVGaWxlOiBqZXN0LmZuKCksXG4gIH0sXG59KSk7XG5cbmplc3QubW9jaygnY2hpbGRfcHJvY2VzcycsICgpID0+ICh7XG4gIGV4ZWNTeW5jOiBqZXN0LmZuKCksXG59KSk7XG5cbmplc3QubW9jaygnLi4vLi4vbGlicy9vYnNlcnZhYmlsaXR5L0NvcmVQcm90ZWN0aW9uJyk7XG5cbmRlc2NyaWJlKCdUcmFuc2Zvcm1hdGlvblJlY29yZGVyJywgKCkgPT4ge1xuICBsZXQgcmVjb3JkZXI6IFRyYW5zZm9ybWF0aW9uUmVjb3JkZXI7XG4gIGxldCBtb2NrQ29uZmlnOiBSZWNvcmRlckNvbmZpZztcbiAgbGV0IG1vY2tDb3JlUHJvdGVjdGlvbjogamVzdC5Nb2NrZWQ8Q29yZVByb3RlY3Rpb24+O1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIG1vY2tDb25maWcgPSB7XG4gICAgICBlbmFibGVGaWxlU3lzdGVtU2luazogdHJ1ZSxcbiAgICAgIGVuYWJsZVN1cGFiYXNlU2luazogZmFsc2UsXG4gICAgICBlbmFibGVDb3JlUHJvdGVjdGlvbjogdHJ1ZSxcbiAgICAgIHJlZGFjdFBhdHRlcm5zOiBbJy5lbnYqJywgJypzZWNyZXQqJ10sXG4gICAgICBwcm90ZWN0ZWRQYXRoczogWydzcmMvdHlwZXMvYWdlbnQudHMnXSxcbiAgICAgIGxlYXJuaW5nUGF0aHM6IFsnZG9jcy9wYXRjaGVzLyoqJ10sXG4gICAgfTtcblxuICAgIG1vY2tDb3JlUHJvdGVjdGlvbiA9IHtcbiAgICAgIHZhbGlkYXRlVHJhbnNmb3JtYXRpb246IGplc3QuZm4oKSxcbiAgICAgIGF1ZGl0Q29yZUludGVncml0eTogamVzdC5mbigpLFxuICAgICAgaXNQcmlzdGluZUNvcmVQYXRoOiBqZXN0LmZuKCksXG4gICAgICBpc0xlYXJuaW5nTGF5ZXJQYXRoOiBqZXN0LmZuKCksXG4gICAgICBlbmZvcmNlUHJvdGVjdGlvbjogamVzdC5mbigpLFxuICAgICAgZ2VuZXJhdGVQcm90ZWN0aW9uUmVwb3J0OiBqZXN0LmZuKCksXG4gICAgfSBhcyBhbnk7XG5cbiAgICAoQ29yZVByb3RlY3Rpb24gYXMgamVzdC5Nb2NrZWRDbGFzczx0eXBlb2YgQ29yZVByb3RlY3Rpb24+KS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gbW9ja0NvcmVQcm90ZWN0aW9uKTtcblxuICAgIHJlY29yZGVyID0gbmV3IFRyYW5zZm9ybWF0aW9uUmVjb3JkZXIobW9ja0NvbmZpZyk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdzdGFydCcsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIG1vY2tDb3JlUHJvdGVjdGlvbi52YWxpZGF0ZVRyYW5zZm9ybWF0aW9uLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgaXNWYWxpZDogdHJ1ZSxcbiAgICAgICAgdmlvbGF0aW9uczogW10sXG4gICAgICAgIHByb3RlY3RlZFBhdGhzOiBbXSxcbiAgICAgICAgYWxsb3dlZFBhdGhzOiBbJ2NvbXBvbmVudHMvY2hhdC9jaGF0LXdpbmRvdy50c3gnXSxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9KTtcblxuICAgICAgKGV4ZWNTeW5jIGFzIGplc3QuTW9jaykubW9ja1JldHVyblZhbHVlKCdhYmMxMjNkZWZcXG4nKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc3RhcnQgdHJhbnNmb3JtYXRpb24gcmVjb3JkaW5nIHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIHBhdGNoSWQ6IDEsXG4gICAgICAgIGJyYW5jaDogJ21haW4nLFxuICAgICAgICBhdXRob3JJZDogJ3VzZXItMTIzJyxcbiAgICAgICAgZmlsZXNUb3VjaGVkOiBbJ2NvbXBvbmVudHMvY2hhdC9jaGF0LXdpbmRvdy50c3gnXSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHRyYW5zZm9ybWF0aW9uSWQgPSBhd2FpdCByZWNvcmRlci5zdGFydChjb250ZXh0KTtcblxuICAgICAgZXhwZWN0KHRyYW5zZm9ybWF0aW9uSWQpLnRvTWF0Y2goL15wYXRjaC0xQFthLWYwLTldezd9JC8pO1xuICAgICAgZXhwZWN0KG1vY2tDb3JlUHJvdGVjdGlvbi52YWxpZGF0ZVRyYW5zZm9ybWF0aW9uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChjb250ZXh0LmZpbGVzVG91Y2hlZCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IGVycm9yIGZvciBjcml0aWNhbCBjb3JlIHZpb2xhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQ29yZVByb3RlY3Rpb24udmFsaWRhdGVUcmFuc2Zvcm1hdGlvbi5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICB2aW9sYXRpb25zOiBbe1xuICAgICAgICAgIHBhdGg6ICdzcmMvdHlwZXMvYWdlbnQudHMnLFxuICAgICAgICAgIHJlYXNvbjogJ1ByaXN0aW5lIGNvcmUgdmlvbGF0aW9uJyxcbiAgICAgICAgICBzZXZlcml0eTogJ2NyaXRpY2FsJyxcbiAgICAgICAgfV0sXG4gICAgICAgIHByb3RlY3RlZFBhdGhzOiBbJ3NyYy90eXBlcy9hZ2VudC50cyddLFxuICAgICAgICBhbGxvd2VkUGF0aHM6IFtdLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBwYXRjaElkOiAxLFxuICAgICAgICBicmFuY2g6ICdtYWluJyxcbiAgICAgICAgYXV0aG9ySWQ6ICd1c2VyLTEyMycsXG4gICAgICAgIGZpbGVzVG91Y2hlZDogWydzcmMvdHlwZXMvYWdlbnQudHMnXSxcbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IGV4cGVjdChyZWNvcmRlci5zdGFydChjb250ZXh0KSkucmVqZWN0cy50b1Rocm93KCdDUklUSUNBTDogUHJpc3RpbmUgY29yZSB2aW9sYXRpb24gZGV0ZWN0ZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYWxsb3cgbm9uLWNyaXRpY2FsIHZpb2xhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQ29yZVByb3RlY3Rpb24udmFsaWRhdGVUcmFuc2Zvcm1hdGlvbi5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICB2aW9sYXRpb25zOiBbe1xuICAgICAgICAgIHBhdGg6ICdzb21lLWZpbGUudHMnLFxuICAgICAgICAgIHJlYXNvbjogJ01pbm9yIHZpb2xhdGlvbicsXG4gICAgICAgICAgc2V2ZXJpdHk6ICd3YXJuaW5nJyxcbiAgICAgICAgfV0sXG4gICAgICAgIHByb3RlY3RlZFBhdGhzOiBbXSxcbiAgICAgICAgYWxsb3dlZFBhdGhzOiBbJ3NvbWUtZmlsZS50cyddLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBwYXRjaElkOiAxLFxuICAgICAgICBicmFuY2g6ICdtYWluJyxcbiAgICAgICAgYXV0aG9ySWQ6ICd1c2VyLTEyMycsXG4gICAgICAgIGZpbGVzVG91Y2hlZDogWydzb21lLWZpbGUudHMnXSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHRyYW5zZm9ybWF0aW9uSWQgPSBhd2FpdCByZWNvcmRlci5zdGFydChjb250ZXh0KTtcbiAgICAgIGV4cGVjdCh0cmFuc2Zvcm1hdGlvbklkKS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnYXR0YWNoVG9vbENhbGwnLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQ29yZVByb3RlY3Rpb24udmFsaWRhdGVUcmFuc2Zvcm1hdGlvbi5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGlzVmFsaWQ6IHRydWUsXG4gICAgICAgIHZpb2xhdGlvbnM6IFtdLFxuICAgICAgICBwcm90ZWN0ZWRQYXRoczogW10sXG4gICAgICAgIGFsbG93ZWRQYXRoczogWyd0ZXN0LnRzeCddLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH0pO1xuXG4gICAgICAoZXhlY1N5bmMgYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWUoJ2FiYzEyM2RlZlxcbicpO1xuXG4gICAgICBhd2FpdCByZWNvcmRlci5zdGFydCh7XG4gICAgICAgIHBhdGNoSWQ6IDEsXG4gICAgICAgIGJyYW5jaDogJ21haW4nLFxuICAgICAgICBhdXRob3JJZDogJ3VzZXItMTIzJyxcbiAgICAgICAgZmlsZXNUb3VjaGVkOiBbJ3Rlc3QudHN4J10sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVjb3JkIHRvb2wgY2FsbHMgbm9ybWFsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0b29sQ2FsbCA9IHtcbiAgICAgICAgaWQ6ICd0b29sLTEnLFxuICAgICAgICBuYW1lOiAnUmVhZCcsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBwYXJhbWV0ZXJzOiB7IGZpbGVfcGF0aDogJ3Rlc3QudHN4JyB9LFxuICAgICAgICBkdXJhdGlvbjogMTAwLFxuICAgICAgICBjb3JlUHJvdGVjdGlvbkNoZWNrOiBmYWxzZSxcbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IHJlY29yZGVyLmF0dGFjaFRvb2xDYWxsKHRvb2xDYWxsKTtcbiAgICAgIC8vIE5vIGV4Y2VwdGlvbiBzaG91bGQgYmUgdGhyb3duXG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRldGVjdCBjb3JlIHByb3RlY3Rpb24gdmlvbGF0aW9ucyBpbiBFZGl0IHRvb2wgY2FsbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQ29yZVByb3RlY3Rpb24uaXNQcmlzdGluZUNvcmVQYXRoLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKTtcblxuICAgICAgY29uc3QgdG9vbENhbGwgPSB7XG4gICAgICAgIGlkOiAndG9vbC0xJyxcbiAgICAgICAgbmFtZTogJ0VkaXQnLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgcGFyYW1ldGVyczogeyBmaWxlX3BhdGg6ICdzcmMvdHlwZXMvYWdlbnQudHMnIH0sXG4gICAgICAgIGR1cmF0aW9uOiAxMDAsXG4gICAgICAgIGNvcmVQcm90ZWN0aW9uQ2hlY2s6IGZhbHNlLFxuICAgICAgfTtcblxuICAgICAgYXdhaXQgcmVjb3JkZXIuYXR0YWNoVG9vbENhbGwodG9vbENhbGwpO1xuXG4gICAgICBleHBlY3QobW9ja0NvcmVQcm90ZWN0aW9uLmlzUHJpc3RpbmVDb3JlUGF0aCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3NyYy90eXBlcy9hZ2VudC50cycpO1xuICAgICAgZXhwZWN0KHRvb2xDYWxsLmNvcmVQcm90ZWN0aW9uQ2hlY2spLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdmaW5hbGl6ZScsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tDb3JlUHJvdGVjdGlvbi52YWxpZGF0ZVRyYW5zZm9ybWF0aW9uLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgaXNWYWxpZDogdHJ1ZSxcbiAgICAgICAgdmlvbGF0aW9uczogW10sXG4gICAgICAgIHByb3RlY3RlZFBhdGhzOiBbXSxcbiAgICAgICAgYWxsb3dlZFBhdGhzOiBbJ3Rlc3QudHN4J10sXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfSk7XG5cbiAgICAgIG1vY2tDb3JlUHJvdGVjdGlvbi5hdWRpdENvcmVJbnRlZ3JpdHkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBpc1ZhbGlkOiB0cnVlLFxuICAgICAgICB2aW9sYXRpb25zOiBbXSxcbiAgICAgICAgcHJvdGVjdGVkUGF0aHM6IFtdLFxuICAgICAgICBhbGxvd2VkUGF0aHM6IFtdLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH0pO1xuXG4gICAgICAoZXhlY1N5bmMgYXMgamVzdC5Nb2NrKVxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnYWJjMTIzZGVmXFxuJykgLy8gZ2l0IHJldi1wYXJzZSBIRUFEXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWVPbmNlKCcnKSAvLyB0eXBlY2hlY2tcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJycpIC8vIGxpbnRcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJ0FsbCBmaWxlcyB8IDk1LjIgfCcpIC8vIHRlc3QgY292ZXJhZ2VcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZU9uY2UoJycpOyAvLyBidWlsZFxuXG4gICAgICBhd2FpdCByZWNvcmRlci5zdGFydCh7XG4gICAgICAgIHBhdGNoSWQ6IDEsXG4gICAgICAgIGJyYW5jaDogJ21haW4nLFxuICAgICAgICBhdXRob3JJZDogJ3VzZXItMTIzJyxcbiAgICAgICAgZmlsZXNUb3VjaGVkOiBbJ3Rlc3QudHN4J10sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZmluYWxpemUgdHJhbnNmb3JtYXRpb24gd2l0aCBhbGwgZ3VhcmRyYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlY29yZCA9IGF3YWl0IHJlY29yZGVyLmZpbmFsaXplKCdUZXN0IHRyYW5zZm9ybWF0aW9uJywgJ3Byb2NlZWQnKTtcblxuICAgICAgZXhwZWN0KHJlY29yZC50cmFuc2Zvcm1hdGlvbi5pZCkudG9NYXRjaCgvXnBhdGNoLTFAW2EtZjAtOV17N30kLyk7XG4gICAgICBleHBlY3QocmVjb3JkLnN1bW1hcnkpLnRvQmUoJ1Rlc3QgdHJhbnNmb3JtYXRpb24nKTtcbiAgICAgIGV4cGVjdChyZWNvcmQuZGVjaXNpb24pLnRvQmUoJ3Byb2NlZWQnKTtcbiAgICAgIGV4cGVjdChyZWNvcmQuY29yZUludGVncml0eVZlcmlmaWVkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlY29yZC5ndWFyZHJhaWxzKS50b0hhdmVMZW5ndGgoNSk7IC8vIHR5cGVjaGVjaywgbGludCwgdGVzdCwgYnVpbGQsIGNvcmVfcHJvdGVjdGlvblxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZ3VhcmRyYWlsIGZhaWx1cmVzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAoZXhlY1N5bmMgYXMgamVzdC5Nb2NrKVxuICAgICAgICAubW9ja1JldHVyblZhbHVlT25jZSgnYWJjMTIzZGVmXFxuJykgLy8gZ2l0IHJldi1wYXJzZSBIRUFEIChmb3Igc3RhcnQpXG4gICAgICAgIC5tb2NrSW1wbGVtZW50YXRpb25PbmNlKCgpID0+IHsgLy8gdHlwZWNoZWNrIGZhaWx1cmVcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignVHlwZSBlcnJvcicpO1xuICAgICAgICAgIChlcnJvciBhcyBhbnkpLnN0YXR1cyA9IDE7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZWNvcmQgPSBhd2FpdCByZWNvcmRlci5maW5hbGl6ZSgnVGVzdCB3aXRoIGZhaWx1cmVzJywgJ2ZpeF9yZXF1aXJlZCcpO1xuXG4gICAgICBleHBlY3QocmVjb3JkLmRlY2lzaW9uKS50b0JlKCdmaXhfcmVxdWlyZWQnKTtcbiAgICAgIGV4cGVjdChyZWNvcmQuZ3VhcmRyYWlscy5zb21lKGcgPT4gZy5uYW1lID09PSAndHlwZWNoZWNrJyAmJiBnLnN0YXR1cyA9PT0gJ2ZhaWwnKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZ2VuZXJhdGUgbGVhcm5pbmcgaW5zaWdodHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCByZWNvcmRlci5hdHRhY2hUb29sQ2FsbCh7XG4gICAgICAgIGlkOiAndG9vbC0xJyxcbiAgICAgICAgbmFtZTogJ0VkaXQnLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgcGFyYW1ldGVyczogeyBmaWxlX3BhdGg6ICd0ZXN0LnRzeCcgfSxcbiAgICAgICAgZHVyYXRpb246IDEwMCxcbiAgICAgICAgY29yZVByb3RlY3Rpb25DaGVjazogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVjb3JkID0gYXdhaXQgcmVjb3JkZXIuZmluYWxpemUoJ1Rlc3QgaW5zaWdodHMnLCAncHJvY2VlZCcpO1xuXG4gICAgICBleHBlY3QocmVjb3JkLmxlYXJuaW5nSW5zaWdodHMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocmVjb3JkLmxlYXJuaW5nSW5zaWdodHMhLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgZXhwZWN0KHJlY29yZC5sZWFybmluZ0luc2lnaHRzIS5zb21lKGluc2lnaHQgPT4gaW5zaWdodC5pbmNsdWRlcygnVG9vbHMgdXNlZDogRWRpdCcpKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0ZpbGVTeXN0ZW1TaW5rJywgKCkgPT4ge1xuICAgIGxldCBzaW5rOiBGaWxlU3lzdGVtU2luaztcbiAgICBsZXQgbW9ja1JlY29yZDogQ29uc2VxdWVuY2VSZWNvcmQ7XG5cbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIHNpbmsgPSBuZXcgRmlsZVN5c3RlbVNpbmsoJy90ZXN0L2Jhc2UvcGF0aCcpO1xuICAgICAgbW9ja1JlY29yZCA9IHtcbiAgICAgICAgdHJhbnNmb3JtYXRpb246IHtcbiAgICAgICAgICBpZDogJ3BhdGNoLTFAYWJjMTIzJyxcbiAgICAgICAgICBwYXRjaElkOiAxLFxuICAgICAgICAgIGJyYW5jaDogJ21haW4nLFxuICAgICAgICAgIGF1dGhvcklkOiAndXNlci0xMjMnLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIGNhdGVnb3JpZXM6IFsnY29kZSddLFxuICAgICAgICAgIGZpbGVzVG91Y2hlZDogWyd0ZXN0LnRzeCddLFxuICAgICAgICAgIGdpdFN0YXRzOiB7XG4gICAgICAgICAgICBzaGE6ICdhYmMxMjNkZWYnLFxuICAgICAgICAgICAgYWRkaXRpb25zOiAxMCxcbiAgICAgICAgICAgIGRlbGV0aW9uczogNSxcbiAgICAgICAgICAgIGNoYW5nZWRGaWxlczogMSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvcmVQcm90ZWN0aW9uU3RhdHVzOiAnc2FmZScsXG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50czogW10sXG4gICAgICAgIGd1YXJkcmFpbHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAndHlwZWNoZWNrJyxcbiAgICAgICAgICAgIHN0YXR1czogJ3Bhc3MnLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBkdXJhdGlvbjogMTAwMCxcbiAgICAgICAgICAgIG1ldHJpY3M6IHsgZXJyb3JzOiAwIH0sXG4gICAgICAgICAgICBhcnRpZmFjdHM6IFtdLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGFydGlmYWN0czogW10sXG4gICAgICAgIHRvb2xDYWxsczogW10sXG4gICAgICAgIHN1bW1hcnk6ICdUZXN0IHRyYW5zZm9ybWF0aW9uJyxcbiAgICAgICAgZGVjaXNpb246ICdwcm9jZWVkJyxcbiAgICAgICAgY29yZUludGVncml0eVZlcmlmaWVkOiB0cnVlLFxuICAgICAgICB2ZXJzaW9uOiAnMS4wJyxcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHdyaXRlIEpTT05MIGxlZGdlciBhbmQgbWFya2Rvd24gY29uc2VxdWVuY2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgc2luay53cml0ZShtb2NrUmVjb3JkKTtcblxuICAgICAgZXhwZWN0KGZzLm1rZGlyKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL3Rlc3QvYmFzZS9wYXRoL2RvY3MvcGF0Y2hlcy9wYXRjaC0xJywgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICBleHBlY3QoZnMuYXBwZW5kRmlsZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICcvdGVzdC9iYXNlL3BhdGgvZG9jcy9wYXRjaGVzL3BhdGNoLTEvbGVkZ2VyLmpzb25sJyxcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ1wiaWRcIjpcInBhdGNoLTFAYWJjMTIzXCInKSxcbiAgICAgICAgJ3V0ZjgnXG4gICAgICApO1xuICAgICAgZXhwZWN0KGZzLndyaXRlRmlsZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICcvdGVzdC9iYXNlL3BhdGgvZG9jcy9wYXRjaGVzL3BhdGNoLTEvQ09OU0VRVUVOQ0VTLm1kJyxcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJyMgVHJhbnNmb3JtYXRpb24gQ29uc2VxdWVuY2VzIC0gUGF0Y2ggMScpLFxuICAgICAgICAndXRmOCdcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGdlbmVyYXRlIGNvbXByZWhlbnNpdmUgbWFya2Rvd24gcmVwb3J0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1JlY29yZC5ndWFyZHJhaWxzLnB1c2goe1xuICAgICAgICBuYW1lOiAndGVzdCcsXG4gICAgICAgIHN0YXR1czogJ2ZhaWwnLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgZHVyYXRpb246IDIwMDAsXG4gICAgICAgIG1ldHJpY3M6IHsgcGFzc2VkOiAwLCBmYWlsZWQ6IDEgfSxcbiAgICAgICAgYXJ0aWZhY3RzOiBbXSxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBzaW5rLndyaXRlKG1vY2tSZWNvcmQpO1xuXG4gICAgICBjb25zdCBtYXJrZG93bkNhbGwgPSAoZnMud3JpdGVGaWxlIGFzIGplc3QuTW9jaykubW9jay5jYWxscy5maW5kKGNhbGwgPT4gXG4gICAgICAgIGNhbGxbMF0uZW5kc1dpdGgoJ0NPTlNFUVVFTkNFUy5tZCcpXG4gICAgICApO1xuICAgICAgY29uc3QgbWFya2Rvd24gPSBtYXJrZG93bkNhbGxbMV07XG5cbiAgICAgIGV4cGVjdChtYXJrZG93bikudG9Db250YWluKCcqKkNvcmUgSW50ZWdyaXR5Kio6IOKchSBWRVJJRklFRCcpO1xuICAgICAgZXhwZWN0KG1hcmtkb3duKS50b0NvbnRhaW4oJyoqRGVjaXNpb24qKjogKipQUk9DRUVEKionKTtcbiAgICAgIGV4cGVjdChtYXJrZG93bikudG9Db250YWluKCcjIyMg4pyFIFBhc3NlZCAoMSknKTtcbiAgICAgIGV4cGVjdChtYXJrZG93bikudG9Db250YWluKCcjIyMg4p2MIEZhaWxlZCAoMSknKTtcbiAgICAgIGV4cGVjdChtYXJrZG93bikudG9Db250YWluKCctIGB0ZXN0LnRzeGAnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsInByb21pc2VzIiwibWtkaXIiLCJmbiIsImFwcGVuZEZpbGUiLCJ3cml0ZUZpbGUiLCJleGVjU3luYyIsImRlc2NyaWJlIiwicmVjb3JkZXIiLCJtb2NrQ29uZmlnIiwibW9ja0NvcmVQcm90ZWN0aW9uIiwiYmVmb3JlRWFjaCIsImVuYWJsZUZpbGVTeXN0ZW1TaW5rIiwiZW5hYmxlU3VwYWJhc2VTaW5rIiwiZW5hYmxlQ29yZVByb3RlY3Rpb24iLCJyZWRhY3RQYXR0ZXJucyIsInByb3RlY3RlZFBhdGhzIiwibGVhcm5pbmdQYXRocyIsInZhbGlkYXRlVHJhbnNmb3JtYXRpb24iLCJhdWRpdENvcmVJbnRlZ3JpdHkiLCJpc1ByaXN0aW5lQ29yZVBhdGgiLCJpc0xlYXJuaW5nTGF5ZXJQYXRoIiwiZW5mb3JjZVByb3RlY3Rpb24iLCJnZW5lcmF0ZVByb3RlY3Rpb25SZXBvcnQiLCJDb3JlUHJvdGVjdGlvbiIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsIlRyYW5zZm9ybWF0aW9uUmVjb3JkZXIiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsImlzVmFsaWQiLCJ2aW9sYXRpb25zIiwiYWxsb3dlZFBhdGhzIiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwibW9ja1JldHVyblZhbHVlIiwiaXQiLCJjb250ZXh0IiwicGF0Y2hJZCIsImJyYW5jaCIsImF1dGhvcklkIiwiZmlsZXNUb3VjaGVkIiwidHJhbnNmb3JtYXRpb25JZCIsInN0YXJ0IiwiZXhwZWN0IiwidG9NYXRjaCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwicGF0aCIsInJlYXNvbiIsInNldmVyaXR5IiwicmVqZWN0cyIsInRvVGhyb3ciLCJ0b0JlRGVmaW5lZCIsInRvb2xDYWxsIiwiaWQiLCJuYW1lIiwicGFyYW1ldGVycyIsImZpbGVfcGF0aCIsImR1cmF0aW9uIiwiY29yZVByb3RlY3Rpb25DaGVjayIsImF0dGFjaFRvb2xDYWxsIiwidG9CZSIsIm1vY2tSZXR1cm5WYWx1ZU9uY2UiLCJyZWNvcmQiLCJmaW5hbGl6ZSIsInRyYW5zZm9ybWF0aW9uIiwic3VtbWFyeSIsImRlY2lzaW9uIiwiY29yZUludGVncml0eVZlcmlmaWVkIiwiZ3VhcmRyYWlscyIsInRvSGF2ZUxlbmd0aCIsIm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UiLCJlcnJvciIsIkVycm9yIiwic3RhdHVzIiwic29tZSIsImciLCJsZWFybmluZ0luc2lnaHRzIiwibGVuZ3RoIiwidG9CZUdyZWF0ZXJUaGFuIiwiaW5zaWdodCIsImluY2x1ZGVzIiwic2luayIsIm1vY2tSZWNvcmQiLCJGaWxlU3lzdGVtU2luayIsImNhdGVnb3JpZXMiLCJnaXRTdGF0cyIsInNoYSIsImFkZGl0aW9ucyIsImRlbGV0aW9ucyIsImNoYW5nZWRGaWxlcyIsImNvcmVQcm90ZWN0aW9uU3RhdHVzIiwiZXZlbnRzIiwibWV0cmljcyIsImVycm9ycyIsImFydGlmYWN0cyIsInRvb2xDYWxscyIsInZlcnNpb24iLCJ3cml0ZSIsImZzIiwicmVjdXJzaXZlIiwic3RyaW5nQ29udGFpbmluZyIsInB1c2giLCJwYXNzZWQiLCJmYWlsZWQiLCJtYXJrZG93bkNhbGwiLCJjYWxscyIsImZpbmQiLCJjYWxsIiwiZW5kc1dpdGgiLCJtYXJrZG93biIsInRvQ29udGFpbiIsImFmdGVyRWFjaCIsImNsZWFyQWxsTW9ja3MiXSwibWFwcGluZ3MiOiI7QUFNQSxvQkFBb0I7QUFDcEJBLEtBQUtDLElBQUksQ0FBQyxNQUFNLElBQU8sQ0FBQTtRQUNyQkMsVUFBVTtZQUNSQyxPQUFPSCxLQUFLSSxFQUFFO1lBQ2RDLFlBQVlMLEtBQUtJLEVBQUU7WUFDbkJFLFdBQVdOLEtBQUtJLEVBQUU7UUFDcEI7SUFDRixDQUFBO0FBRUFKLEtBQUtDLElBQUksQ0FBQyxpQkFBaUIsSUFBTyxDQUFBO1FBQ2hDTSxVQUFVUCxLQUFLSSxFQUFFO0lBQ25CLENBQUE7QUFFQUosS0FBS0MsSUFBSSxDQUFDOzs7O3dDQW5CNkM7Z0NBQ3hCO29CQUVBOytCQUNOO0FBaUJ6Qk8sU0FBUywwQkFBMEI7SUFDakMsSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBRUpDLFdBQVc7UUFDVEYsYUFBYTtZQUNYRyxzQkFBc0I7WUFDdEJDLG9CQUFvQjtZQUNwQkMsc0JBQXNCO1lBQ3RCQyxnQkFBZ0I7Z0JBQUM7Z0JBQVM7YUFBVztZQUNyQ0MsZ0JBQWdCO2dCQUFDO2FBQXFCO1lBQ3RDQyxlQUFlO2dCQUFDO2FBQWtCO1FBQ3BDO1FBRUFQLHFCQUFxQjtZQUNuQlEsd0JBQXdCbkIsS0FBS0ksRUFBRTtZQUMvQmdCLG9CQUFvQnBCLEtBQUtJLEVBQUU7WUFDM0JpQixvQkFBb0JyQixLQUFLSSxFQUFFO1lBQzNCa0IscUJBQXFCdEIsS0FBS0ksRUFBRTtZQUM1Qm1CLG1CQUFtQnZCLEtBQUtJLEVBQUU7WUFDMUJvQiwwQkFBMEJ4QixLQUFLSSxFQUFFO1FBQ25DO1FBRUNxQiw4QkFBYyxDQUE2Q0Msa0JBQWtCLENBQUMsSUFBTWY7UUFFckZGLFdBQVcsSUFBSWtCLDhDQUFzQixDQUFDakI7SUFDeEM7SUFFQUYsU0FBUyxTQUFTO1FBQ2hCSSxXQUFXO1lBQ1RELG1CQUFtQlEsc0JBQXNCLENBQUNTLGlCQUFpQixDQUFDO2dCQUMxREMsU0FBUztnQkFDVEMsWUFBWSxFQUFFO2dCQUNkYixnQkFBZ0IsRUFBRTtnQkFDbEJjLGNBQWM7b0JBQUM7aUJBQWtDO2dCQUNqREMsV0FBVyxJQUFJQyxPQUFPQyxXQUFXO1lBQ25DO1lBRUMzQix1QkFBUSxDQUFlNEIsZUFBZSxDQUFDO1FBQzFDO1FBRUFDLEdBQUcsc0RBQXNEO1lBQ3ZELE1BQU1DLFVBQVU7Z0JBQ2RDLFNBQVM7Z0JBQ1RDLFFBQVE7Z0JBQ1JDLFVBQVU7Z0JBQ1ZDLGNBQWM7b0JBQUM7aUJBQWtDO1lBQ25EO1lBRUEsTUFBTUMsbUJBQW1CLE1BQU1qQyxTQUFTa0MsS0FBSyxDQUFDTjtZQUU5Q08sT0FBT0Ysa0JBQWtCRyxPQUFPLENBQUM7WUFDakNELE9BQU9qQyxtQkFBbUJRLHNCQUFzQixFQUFFMkIsb0JBQW9CLENBQUNULFFBQVFJLFlBQVk7UUFDN0Y7UUFFQUwsR0FBRyxtREFBbUQ7WUFDcER6QixtQkFBbUJRLHNCQUFzQixDQUFDUyxpQkFBaUIsQ0FBQztnQkFDMURDLFNBQVM7Z0JBQ1RDLFlBQVk7b0JBQUM7d0JBQ1hpQixNQUFNO3dCQUNOQyxRQUFRO3dCQUNSQyxVQUFVO29CQUNaO2lCQUFFO2dCQUNGaEMsZ0JBQWdCO29CQUFDO2lCQUFxQjtnQkFDdENjLGNBQWMsRUFBRTtnQkFDaEJDLFdBQVcsSUFBSUMsT0FBT0MsV0FBVztZQUNuQztZQUVBLE1BQU1HLFVBQVU7Z0JBQ2RDLFNBQVM7Z0JBQ1RDLFFBQVE7Z0JBQ1JDLFVBQVU7Z0JBQ1ZDLGNBQWM7b0JBQUM7aUJBQXFCO1lBQ3RDO1lBRUEsTUFBTUcsT0FBT25DLFNBQVNrQyxLQUFLLENBQUNOLFVBQVVhLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDO1FBQ3hEO1FBRUFmLEdBQUcsd0NBQXdDO1lBQ3pDekIsbUJBQW1CUSxzQkFBc0IsQ0FBQ1MsaUJBQWlCLENBQUM7Z0JBQzFEQyxTQUFTO2dCQUNUQyxZQUFZO29CQUFDO3dCQUNYaUIsTUFBTTt3QkFDTkMsUUFBUTt3QkFDUkMsVUFBVTtvQkFDWjtpQkFBRTtnQkFDRmhDLGdCQUFnQixFQUFFO2dCQUNsQmMsY0FBYztvQkFBQztpQkFBZTtnQkFDOUJDLFdBQVcsSUFBSUMsT0FBT0MsV0FBVztZQUNuQztZQUVBLE1BQU1HLFVBQVU7Z0JBQ2RDLFNBQVM7Z0JBQ1RDLFFBQVE7Z0JBQ1JDLFVBQVU7Z0JBQ1ZDLGNBQWM7b0JBQUM7aUJBQWU7WUFDaEM7WUFFQSxNQUFNQyxtQkFBbUIsTUFBTWpDLFNBQVNrQyxLQUFLLENBQUNOO1lBQzlDTyxPQUFPRixrQkFBa0JVLFdBQVc7UUFDdEM7SUFDRjtJQUVBNUMsU0FBUyxrQkFBa0I7UUFDekJJLFdBQVc7WUFDVEQsbUJBQW1CUSxzQkFBc0IsQ0FBQ1MsaUJBQWlCLENBQUM7Z0JBQzFEQyxTQUFTO2dCQUNUQyxZQUFZLEVBQUU7Z0JBQ2RiLGdCQUFnQixFQUFFO2dCQUNsQmMsY0FBYztvQkFBQztpQkFBVztnQkFDMUJDLFdBQVcsSUFBSUMsT0FBT0MsV0FBVztZQUNuQztZQUVDM0IsdUJBQVEsQ0FBZTRCLGVBQWUsQ0FBQztZQUV4QyxNQUFNMUIsU0FBU2tDLEtBQUssQ0FBQztnQkFDbkJMLFNBQVM7Z0JBQ1RDLFFBQVE7Z0JBQ1JDLFVBQVU7Z0JBQ1ZDLGNBQWM7b0JBQUM7aUJBQVc7WUFDNUI7UUFDRjtRQUVBTCxHQUFHLHFDQUFxQztZQUN0QyxNQUFNaUIsV0FBVztnQkFDZkMsSUFBSTtnQkFDSkMsTUFBTTtnQkFDTnZCLFdBQVcsSUFBSUMsT0FBT0MsV0FBVztnQkFDakNzQixZQUFZO29CQUFFQyxXQUFXO2dCQUFXO2dCQUNwQ0MsVUFBVTtnQkFDVkMscUJBQXFCO1lBQ3ZCO1lBRUEsTUFBTWxELFNBQVNtRCxjQUFjLENBQUNQO1FBQzlCLGdDQUFnQztRQUNsQztRQUVBakIsR0FBRywrREFBK0Q7WUFDaEV6QixtQkFBbUJVLGtCQUFrQixDQUFDYyxlQUFlLENBQUM7WUFFdEQsTUFBTWtCLFdBQVc7Z0JBQ2ZDLElBQUk7Z0JBQ0pDLE1BQU07Z0JBQ052QixXQUFXLElBQUlDLE9BQU9DLFdBQVc7Z0JBQ2pDc0IsWUFBWTtvQkFBRUMsV0FBVztnQkFBcUI7Z0JBQzlDQyxVQUFVO2dCQUNWQyxxQkFBcUI7WUFDdkI7WUFFQSxNQUFNbEQsU0FBU21ELGNBQWMsQ0FBQ1A7WUFFOUJULE9BQU9qQyxtQkFBbUJVLGtCQUFrQixFQUFFeUIsb0JBQW9CLENBQUM7WUFDbkVGLE9BQU9TLFNBQVNNLG1CQUFtQixFQUFFRSxJQUFJLENBQUM7UUFDNUM7SUFDRjtJQUVBckQsU0FBUyxZQUFZO1FBQ25CSSxXQUFXO1lBQ1RELG1CQUFtQlEsc0JBQXNCLENBQUNTLGlCQUFpQixDQUFDO2dCQUMxREMsU0FBUztnQkFDVEMsWUFBWSxFQUFFO2dCQUNkYixnQkFBZ0IsRUFBRTtnQkFDbEJjLGNBQWM7b0JBQUM7aUJBQVc7Z0JBQzFCQyxXQUFXLElBQUlDLE9BQU9DLFdBQVc7WUFDbkM7WUFFQXZCLG1CQUFtQlMsa0JBQWtCLENBQUNRLGlCQUFpQixDQUFDO2dCQUN0REMsU0FBUztnQkFDVEMsWUFBWSxFQUFFO2dCQUNkYixnQkFBZ0IsRUFBRTtnQkFDbEJjLGNBQWMsRUFBRTtnQkFDaEJDLFdBQVcsSUFBSUMsT0FBT0MsV0FBVztZQUNuQztZQUVDM0IsdUJBQVEsQ0FDTnVELG1CQUFtQixDQUFDLGVBQWUscUJBQXFCO2FBQ3hEQSxtQkFBbUIsQ0FBQyxJQUFJLFlBQVk7YUFDcENBLG1CQUFtQixDQUFDLElBQUksT0FBTzthQUMvQkEsbUJBQW1CLENBQUMsc0JBQXNCLGdCQUFnQjthQUMxREEsbUJBQW1CLENBQUMsS0FBSyxRQUFRO1lBRXBDLE1BQU1yRCxTQUFTa0MsS0FBSyxDQUFDO2dCQUNuQkwsU0FBUztnQkFDVEMsUUFBUTtnQkFDUkMsVUFBVTtnQkFDVkMsY0FBYztvQkFBQztpQkFBVztZQUM1QjtRQUNGO1FBRUFMLEdBQUcsc0RBQXNEO1lBQ3ZELE1BQU0yQixTQUFTLE1BQU10RCxTQUFTdUQsUUFBUSxDQUFDLHVCQUF1QjtZQUU5RHBCLE9BQU9tQixPQUFPRSxjQUFjLENBQUNYLEVBQUUsRUFBRVQsT0FBTyxDQUFDO1lBQ3pDRCxPQUFPbUIsT0FBT0csT0FBTyxFQUFFTCxJQUFJLENBQUM7WUFDNUJqQixPQUFPbUIsT0FBT0ksUUFBUSxFQUFFTixJQUFJLENBQUM7WUFDN0JqQixPQUFPbUIsT0FBT0sscUJBQXFCLEVBQUVQLElBQUksQ0FBQztZQUMxQ2pCLE9BQU9tQixPQUFPTSxVQUFVLEVBQUVDLFlBQVksQ0FBQyxJQUFJLGdEQUFnRDtRQUM3RjtRQUVBbEMsR0FBRywrQ0FBK0M7WUFDL0M3Qix1QkFBUSxDQUNOdUQsbUJBQW1CLENBQUMsZUFBZSxpQ0FBaUM7YUFDcEVTLHNCQUFzQixDQUFDO2dCQUN0QixNQUFNQyxRQUFRLElBQUlDLE1BQU07Z0JBQ3ZCRCxNQUFjRSxNQUFNLEdBQUc7Z0JBQ3hCLE1BQU1GO1lBQ1I7WUFFRixNQUFNVCxTQUFTLE1BQU10RCxTQUFTdUQsUUFBUSxDQUFDLHNCQUFzQjtZQUU3RHBCLE9BQU9tQixPQUFPSSxRQUFRLEVBQUVOLElBQUksQ0FBQztZQUM3QmpCLE9BQU9tQixPQUFPTSxVQUFVLENBQUNNLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRXJCLElBQUksS0FBSyxlQUFlcUIsRUFBRUYsTUFBTSxLQUFLLFNBQVNiLElBQUksQ0FBQztRQUMxRjtRQUVBekIsR0FBRyxxQ0FBcUM7WUFDdEMsTUFBTTNCLFNBQVNtRCxjQUFjLENBQUM7Z0JBQzVCTixJQUFJO2dCQUNKQyxNQUFNO2dCQUNOdkIsV0FBVyxJQUFJQyxPQUFPQyxXQUFXO2dCQUNqQ3NCLFlBQVk7b0JBQUVDLFdBQVc7Z0JBQVc7Z0JBQ3BDQyxVQUFVO2dCQUNWQyxxQkFBcUI7WUFDdkI7WUFFQSxNQUFNSSxTQUFTLE1BQU10RCxTQUFTdUQsUUFBUSxDQUFDLGlCQUFpQjtZQUV4RHBCLE9BQU9tQixPQUFPYyxnQkFBZ0IsRUFBRXpCLFdBQVc7WUFDM0NSLE9BQU9tQixPQUFPYyxnQkFBZ0IsQ0FBRUMsTUFBTSxFQUFFQyxlQUFlLENBQUM7WUFDeERuQyxPQUFPbUIsT0FBT2MsZ0JBQWdCLENBQUVGLElBQUksQ0FBQ0ssQ0FBQUEsVUFBV0EsUUFBUUMsUUFBUSxDQUFDLHNCQUFzQnBCLElBQUksQ0FBQztRQUM5RjtJQUNGO0lBRUFyRCxTQUFTLGtCQUFrQjtRQUN6QixJQUFJMEU7UUFDSixJQUFJQztRQUVKdkUsV0FBVztZQUNUc0UsT0FBTyxJQUFJRSxzQ0FBYyxDQUFDO1lBQzFCRCxhQUFhO2dCQUNYbEIsZ0JBQWdCO29CQUNkWCxJQUFJO29CQUNKaEIsU0FBUztvQkFDVEMsUUFBUTtvQkFDUkMsVUFBVTtvQkFDVlIsV0FBVyxJQUFJQyxPQUFPQyxXQUFXO29CQUNqQ21ELFlBQVk7d0JBQUM7cUJBQU87b0JBQ3BCNUMsY0FBYzt3QkFBQztxQkFBVztvQkFDMUI2QyxVQUFVO3dCQUNSQyxLQUFLO3dCQUNMQyxXQUFXO3dCQUNYQyxXQUFXO3dCQUNYQyxjQUFjO29CQUNoQjtvQkFDQUMsc0JBQXNCO2dCQUN4QjtnQkFDQUMsUUFBUSxFQUFFO2dCQUNWdkIsWUFBWTtvQkFDVjt3QkFDRWQsTUFBTTt3QkFDTm1CLFFBQVE7d0JBQ1IxQyxXQUFXLElBQUlDLE9BQU9DLFdBQVc7d0JBQ2pDd0IsVUFBVTt3QkFDVm1DLFNBQVM7NEJBQUVDLFFBQVE7d0JBQUU7d0JBQ3JCQyxXQUFXLEVBQUU7b0JBQ2Y7aUJBQ0Q7Z0JBQ0RBLFdBQVcsRUFBRTtnQkFDYkMsV0FBVyxFQUFFO2dCQUNiOUIsU0FBUztnQkFDVEMsVUFBVTtnQkFDVkMsdUJBQXVCO2dCQUN2QjZCLFNBQVM7WUFDWDtRQUNGO1FBRUE3RCxHQUFHLHVEQUF1RDtZQUN4RCxNQUFNOEMsS0FBS2dCLEtBQUssQ0FBQ2Y7WUFFakJ2QyxPQUFPdUQsWUFBRSxDQUFDaEcsS0FBSyxFQUFFMkMsb0JBQW9CLENBQUMsd0NBQXdDO2dCQUFFc0QsV0FBVztZQUFLO1lBQ2hHeEQsT0FBT3VELFlBQUUsQ0FBQzlGLFVBQVUsRUFBRXlDLG9CQUFvQixDQUN4QyxxREFDQUYsT0FBT3lELGdCQUFnQixDQUFDLDBCQUN4QjtZQUVGekQsT0FBT3VELFlBQUUsQ0FBQzdGLFNBQVMsRUFBRXdDLG9CQUFvQixDQUN2Qyx3REFDQUYsT0FBT3lELGdCQUFnQixDQUFDLDRDQUN4QjtRQUVKO1FBRUFqRSxHQUFHLGlEQUFpRDtZQUNsRCtDLFdBQVdkLFVBQVUsQ0FBQ2lDLElBQUksQ0FBQztnQkFDekIvQyxNQUFNO2dCQUNObUIsUUFBUTtnQkFDUjFDLFdBQVcsSUFBSUMsT0FBT0MsV0FBVztnQkFDakN3QixVQUFVO2dCQUNWbUMsU0FBUztvQkFBRVUsUUFBUTtvQkFBR0MsUUFBUTtnQkFBRTtnQkFDaENULFdBQVcsRUFBRTtZQUNmO1lBRUEsTUFBTWIsS0FBS2dCLEtBQUssQ0FBQ2Y7WUFFakIsTUFBTXNCLGVBQWUsQUFBQ04sWUFBRSxDQUFDN0YsU0FBUyxDQUFlTCxJQUFJLENBQUN5RyxLQUFLLENBQUNDLElBQUksQ0FBQ0MsQ0FBQUEsT0FDL0RBLElBQUksQ0FBQyxFQUFFLENBQUNDLFFBQVEsQ0FBQztZQUVuQixNQUFNQyxXQUFXTCxZQUFZLENBQUMsRUFBRTtZQUVoQzdELE9BQU9rRSxVQUFVQyxTQUFTLENBQUM7WUFDM0JuRSxPQUFPa0UsVUFBVUMsU0FBUyxDQUFDO1lBQzNCbkUsT0FBT2tFLFVBQVVDLFNBQVMsQ0FBQztZQUMzQm5FLE9BQU9rRSxVQUFVQyxTQUFTLENBQUM7WUFDM0JuRSxPQUFPa0UsVUFBVUMsU0FBUyxDQUFDO1FBQzdCO0lBQ0Y7SUFFQUMsVUFBVTtRQUNSaEgsS0FBS2lILGFBQWE7SUFDcEI7QUFDRiJ9