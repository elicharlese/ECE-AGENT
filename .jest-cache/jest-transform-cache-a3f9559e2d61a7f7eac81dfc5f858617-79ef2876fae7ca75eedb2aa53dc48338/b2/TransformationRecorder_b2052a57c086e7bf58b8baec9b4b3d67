e21014ad310a20f63ed97574932d2a90
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    FileSystemSink: function() {
        return FileSystemSink;
    },
    SupabaseSink: function() {
        return SupabaseSink;
    },
    TransformationRecorder: function() {
        return TransformationRecorder;
    }
});
const _fs = require("fs");
const _path = require("path");
const _child_process = require("child_process");
const _agentobservability = require("../../src/types/agent-observability");
const _CoreProtection = require("./CoreProtection");
class FileSystemSink {
    constructor(basePath){
        this.basePath = basePath;
    }
    async write(record) {
        const patchDir = (0, _path.join)(this.basePath, "docs", "patches", `patch-${record.transformation.patchId}`);
        // Ensure directory exists
        await _fs.promises.mkdir(patchDir, {
            recursive: true
        });
        // Write JSONL ledger entry
        const ledgerPath = (0, _path.join)(patchDir, "ledger.jsonl");
        const ledgerEntry = JSON.stringify(record) + "\n";
        await _fs.promises.appendFile(ledgerPath, ledgerEntry, "utf8");
        // Write human-readable consequences
        const consequencesPath = (0, _path.join)(patchDir, "CONSEQUENCES.md");
        const markdown = this.generateConsequencesMarkdown(record);
        await _fs.promises.writeFile(consequencesPath, markdown, "utf8");
    }
    generateConsequencesMarkdown(record) {
        const { transformation, guardrails, summary, decision, coreIntegrityVerified } = record;
        const passedGuardrails = guardrails.filter((g)=>g.status === "pass");
        const failedGuardrails = guardrails.filter((g)=>g.status === "fail");
        const warningGuardrails = guardrails.filter((g)=>g.status === "warn");
        return `# Transformation Consequences - Patch ${transformation.patchId}

**Transformation ID**: \`${transformation.id}\`  
**Branch**: \`${transformation.branch}\`  
**Timestamp**: ${transformation.timestamp}  
**Core Integrity**: ${coreIntegrityVerified ? "✅ VERIFIED" : "❌ COMPROMISED"}  
**Decision**: **${decision.toUpperCase()}**

## Summary

${summary}

## Files Modified

${transformation.filesTouched.map((f)=>`- \`${f}\``).join("\n")}

## Git Statistics

- **Additions**: ${transformation.gitStats.additions}
- **Deletions**: ${transformation.gitStats.deletions}
- **Changed Files**: ${transformation.gitStats.changedFiles}
- **SHA**: \`${transformation.gitStats.sha}\`

## Core Protection Status

**Status**: \`${transformation.coreProtectionStatus}\`

${transformation.coreProtectionStatus === "violation_detected" ? "⚠️ **WARNING**: Pristine core violation detected but blocked by protection mechanisms." : transformation.coreProtectionStatus === "violation_blocked" ? "\uD83D\uDED1 **CRITICAL**: Attempted pristine core modification was blocked." : "✅ No pristine core violations detected."}

## Guardrail Results

### ✅ Passed (${passedGuardrails.length})
${passedGuardrails.map((g)=>`- **${g.name}**: ${Object.entries(g.metrics).map(([k, v])=>`${k}=${v}`).join(", ")}`).join("\n")}

${failedGuardrails.length > 0 ? `### ❌ Failed (${failedGuardrails.length})
${failedGuardrails.map((g)=>`- **${g.name}**: ${Object.entries(g.metrics).map(([k, v])=>`${k}=${v}`).join(", ")}`).join("\n")}` : ""}

${warningGuardrails.length > 0 ? `### ⚠️ Warnings (${warningGuardrails.length})
${warningGuardrails.map((g)=>`- **${g.name}**: ${Object.entries(g.metrics).map(([k, v])=>`${k}=${v}`).join(", ")}`).join("\n")}` : ""}

## Learning Insights

${record.learningInsights?.length ? record.learningInsights.map((insight)=>`- ${insight}`).join("\n") : "No adaptive learning insights recorded."}

---
*Generated by TransformationRecorder v${record.version}*
`;
    }
}
class SupabaseSink {
    constructor(supabaseClient){
        this.supabaseClient = supabaseClient;
    }
    async write(record) {
        // Transform to database schema
        const transformationRow = {
            id: record.transformation.id,
            patch_id: record.transformation.patchId,
            batch_id: record.transformation.batchId || null,
            branch: record.transformation.branch,
            author_id: record.transformation.authorId,
            created_at: record.transformation.timestamp,
            categories: record.transformation.categories,
            files_touched: record.transformation.filesTouched,
            git_stats: record.transformation.gitStats,
            core_protection_status: record.transformation.coreProtectionStatus,
            summary: record.summary,
            decision: record.decision,
            core_integrity_verified: record.coreIntegrityVerified
        };
        // Insert transformation
        const { error: transformationError } = await this.supabaseClient.from("transformations").insert(transformationRow);
        if (transformationError) {
            throw new Error(`Failed to insert transformation: ${transformationError.message}`);
        }
        // Insert guardrails
        const guardrailRows = record.guardrails.map((g)=>({
                id: `${record.transformation.id}-${g.name}`,
                transformation_id: record.transformation.id,
                name: g.name,
                status: g.status,
                created_at: g.timestamp,
                duration: g.duration,
                metrics: g.metrics,
                exit_code: g.exitCode || null
            }));
        if (guardrailRows.length > 0) {
            const { error: guardrailError } = await this.supabaseClient.from("guardrails").insert(guardrailRows);
            if (guardrailError) {
                throw new Error(`Failed to insert guardrails: ${guardrailError.message}`);
            }
        }
        // Insert artifacts
        const artifactRows = record.artifacts.map((a)=>({
                id: a.id,
                transformation_id: record.transformation.id,
                kind: a.kind,
                path: a.path,
                hash: a.hash || null,
                size: a.size || null,
                metadata: a.metadata || null,
                created_at: new Date().toISOString()
            }));
        if (artifactRows.length > 0) {
            const { error: artifactError } = await this.supabaseClient.from("artifacts").insert(artifactRows);
            if (artifactError) {
                throw new Error(`Failed to insert artifacts: ${artifactError.message}`);
            }
        }
    }
}
class TransformationRecorder {
    constructor(config){
        this.config = config;
        this.transformation = null;
        this.events = [];
        this.guardrails = [];
        this.artifacts = [];
        this.toolCalls = [];
        this.sinks = [];
        this.config = _agentobservability.RecorderConfigSchema.parse(config);
        this.coreProtection = new _CoreProtection.CoreProtection(config);
        // Initialize sinks
        if (config.enableFileSystemSink) {
            this.sinks.push(new FileSystemSink(process.cwd()));
        }
        if (config.enableSupabaseSink && process.env.SUPABASE_CLIENT) {
        // Note: Supabase client would be injected in real implementation
        // this.sinks.push(new SupabaseSink(supabaseClient));
        }
    }
    async start(context) {
        // Validate core protection BEFORE starting
        const coreProtectionResult = await this.coreProtection.validateTransformation(context.filesTouched);
        if (!coreProtectionResult.isValid && coreProtectionResult.violations.some((v)=>v.severity === "critical")) {
            throw new Error(`CRITICAL: Pristine core violation detected. Cannot proceed with transformation.`);
        }
        // Get git information
        const gitStats = this.getGitStats();
        const transformationId = `patch-${context.patchId}@${gitStats.sha.substring(0, 7)}`;
        this.transformation = _agentobservability.TransformationSchema.parse({
            id: transformationId,
            patchId: context.patchId,
            batchId: context.batchId,
            branch: context.branch,
            authorId: context.authorId,
            timestamp: new Date().toISOString(),
            categories: this.categorizeFiles(context.filesTouched),
            filesTouched: context.filesTouched,
            gitStats,
            coreProtectionStatus: coreProtectionResult.isValid ? "safe" : "violation_detected"
        });
        // Record start event
        await this.attachEvent({
            name: "transformation_started",
            timestamp: new Date().toISOString(),
            severity: "info",
            payload: {
                transformationId,
                filesTouched: context.filesTouched
            },
            category: "system"
        });
        return transformationId;
    }
    async attachEvent(event) {
        this.events.push(event);
    }
    async attachArtifact(artifact) {
        this.artifacts.push(artifact);
    }
    async attachToolCall(toolCall) {
        // Validate tool call against core protection if enabled
        if (this.config.enableCoreProtection && toolCall.name === "Edit") {
            const filePath = toolCall.parameters.file_path;
            if (filePath && this.coreProtection.isPristineCorePath(filePath)) {
                toolCall.coreProtectionCheck = true;
                await this.attachEvent({
                    name: "core_protection_violation",
                    timestamp: new Date().toISOString(),
                    severity: "critical",
                    payload: {
                        toolCall: toolCall.name,
                        filePath
                    },
                    category: "core_protection"
                });
            }
        }
        this.toolCalls.push(toolCall);
    }
    async finalize(summary, decision) {
        if (!this.transformation) {
            throw new Error("Cannot finalize: transformation not started");
        }
        // Run all guardrails
        await this.runGuardrails();
        // Final core integrity check
        const finalCoreCheck = await this.coreProtection.auditCoreIntegrity();
        const coreIntegrityVerified = finalCoreCheck.isValid;
        // Generate learning insights
        const learningInsights = this.generateLearningInsights();
        const record = _agentobservability.ConsequenceRecordSchema.parse({
            transformation: this.transformation,
            events: this.events,
            guardrails: this.guardrails,
            artifacts: this.artifacts,
            toolCalls: this.toolCalls,
            summary,
            decision,
            coreIntegrityVerified,
            learningInsights,
            redactions: this.config.redactPatterns,
            version: "1.0"
        });
        // Write to all sinks
        for (const sink of this.sinks){
            await sink.write(record);
        }
        // Record completion event
        await this.attachEvent({
            name: "transformation_completed",
            timestamp: new Date().toISOString(),
            severity: "info",
            payload: {
                decision,
                coreIntegrityVerified
            },
            category: "system"
        });
        return record;
    }
    async runGuardrails() {
        const guardrailRunners = [
            ()=>this.runTypecheck(),
            ()=>this.runLint(),
            ()=>this.runTests(),
            ()=>this.runBuild(),
            ()=>this.runCoreProtection()
        ];
        for (const runner of guardrailRunners){
            try {
                const result = await runner();
                this.guardrails.push(result);
            } catch (error) {
                // Continue with other guardrails even if one fails
                console.warn(`Guardrail failed: ${error}`);
            }
        }
    }
    async runTypecheck() {
        const start = Date.now();
        try {
            const output = (0, _child_process.execSync)("pnpm typecheck", {
                encoding: "utf8",
                timeout: 30000
            });
            return {
                name: "typecheck",
                status: "pass",
                timestamp: new Date().toISOString(),
                duration: Date.now() - start,
                metrics: {
                    errors: 0
                },
                artifacts: [],
                exitCode: 0,
                stdout: output
            };
        } catch (error) {
            return {
                name: "typecheck",
                status: "fail",
                timestamp: new Date().toISOString(),
                duration: Date.now() - start,
                metrics: {
                    errors: 1
                },
                artifacts: [],
                exitCode: error.status || 1,
                stderr: error.message
            };
        }
    }
    async runLint() {
        const start = Date.now();
        try {
            const output = (0, _child_process.execSync)("pnpm lint", {
                encoding: "utf8",
                timeout: 30000
            });
            return {
                name: "lint",
                status: "pass",
                timestamp: new Date().toISOString(),
                duration: Date.now() - start,
                metrics: {
                    errors: 0,
                    warnings: 0
                },
                artifacts: [],
                exitCode: 0,
                stdout: output
            };
        } catch (error) {
            return {
                name: "lint",
                status: "fail",
                timestamp: new Date().toISOString(),
                duration: Date.now() - start,
                metrics: {
                    errors: 1
                },
                artifacts: [],
                exitCode: error.status || 1,
                stderr: error.message
            };
        }
    }
    async runTests() {
        const start = Date.now();
        try {
            const output = (0, _child_process.execSync)("pnpm test --coverage --passWithNoTests", {
                encoding: "utf8",
                timeout: 60000
            });
            // Parse coverage from output (simplified)
            const coverageMatch = output.match(/All files[^|]*\|[^|]*\|[^|]*\|[^|]*\|[^|]*(\d+\.?\d*)/);
            const coverage = coverageMatch ? parseFloat(coverageMatch[1]) : 0;
            return {
                name: "test",
                status: coverage >= 90 ? "pass" : "warn",
                timestamp: new Date().toISOString(),
                duration: Date.now() - start,
                metrics: {
                    coverage,
                    passed: 1,
                    failed: 0
                },
                artifacts: [
                    "coverage/lcov-report/index.html"
                ],
                exitCode: 0,
                stdout: output
            };
        } catch (error) {
            return {
                name: "test",
                status: "fail",
                timestamp: new Date().toISOString(),
                duration: Date.now() - start,
                metrics: {
                    coverage: 0,
                    passed: 0,
                    failed: 1
                },
                artifacts: [],
                exitCode: error.status || 1,
                stderr: error.message
            };
        }
    }
    async runBuild() {
        const start = Date.now();
        try {
            const output = (0, _child_process.execSync)("pnpm build", {
                encoding: "utf8",
                timeout: 120000
            });
            return {
                name: "build",
                status: "pass",
                timestamp: new Date().toISOString(),
                duration: Date.now() - start,
                metrics: {
                    success: true
                },
                artifacts: [
                    ".next/build-manifest.json"
                ],
                exitCode: 0,
                stdout: output
            };
        } catch (error) {
            return {
                name: "build",
                status: "fail",
                timestamp: new Date().toISOString(),
                duration: Date.now() - start,
                metrics: {
                    success: false
                },
                artifacts: [],
                exitCode: error.status || 1,
                stderr: error.message
            };
        }
    }
    async runCoreProtection() {
        const start = Date.now();
        const result = await this.coreProtection.auditCoreIntegrity();
        return {
            name: "core_protection",
            status: result.isValid ? "pass" : "fail",
            timestamp: new Date().toISOString(),
            duration: Date.now() - start,
            metrics: {
                violations: result.violations.length,
                protectedPaths: result.protectedPaths.length,
                allowedPaths: result.allowedPaths.length
            },
            artifacts: []
        };
    }
    getGitStats() {
        try {
            const sha = (0, _child_process.execSync)("git rev-parse HEAD", {
                encoding: "utf8"
            }).trim();
            const stats = (0, _child_process.execSync)("git diff --stat HEAD~1", {
                encoding: "utf8"
            });
            // Parse git diff stats (simplified)
            const lines = stats.split("\n");
            const summaryLine = lines[lines.length - 2] || "";
            const match = summaryLine.match(/(\d+) files? changed(?:, (\d+) insertions?)?(?:, (\d+) deletions?)?/);
            return {
                sha,
                additions: match ? parseInt(match[2] || "0") : 0,
                deletions: match ? parseInt(match[3] || "0") : 0,
                changedFiles: match ? parseInt(match[1]) : 0
            };
        } catch  {
            return {
                sha: "unknown",
                additions: 0,
                deletions: 0,
                changedFiles: 0
            };
        }
    }
    categorizeFiles(files) {
        const categories = new Set();
        for (const file of files){
            if (file.match(/\.(ts|tsx|js|jsx)$/)) categories.add("code");
            if (file.match(/\.(json|yaml|yml|env|config)$/)) categories.add("config");
            if (file.match(/prisma|migrations|\.sql$/)) categories.add("database");
            if (file.match(/\.github|docker|vercel|\.config\./)) categories.add("infrastructure");
            if (file.match(/\.md$|docs\//)) categories.add("docs");
        }
        return Array.from(categories);
    }
    generateLearningInsights() {
        const insights = [];
        // Analyze guardrail patterns
        const failedGuardrails = this.guardrails.filter((g)=>g.status === "fail");
        if (failedGuardrails.length > 0) {
            insights.push(`Failed guardrails: ${failedGuardrails.map((g)=>g.name).join(", ")}`);
        }
        // Analyze file patterns
        if (this.transformation) {
            const fileTypes = this.transformation.filesTouched.map((f)=>f.split(".").pop()).filter(Boolean);
            const uniqueTypes = [
                ...new Set(fileTypes)
            ];
            insights.push(`File types modified: ${uniqueTypes.join(", ")}`);
        }
        // Analyze tool usage
        const toolNames = [
            ...new Set(this.toolCalls.map((t)=>t.name))
        ];
        if (toolNames.length > 0) {
            insights.push(`Tools used: ${toolNames.join(", ")}`);
        }
        return insights;
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbGljaGFybGVzZS9DYXNjYWRlUHJvamVjdHMvQUdFTlQvbGlicy9vYnNlcnZhYmlsaXR5L1RyYW5zZm9ybWF0aW9uUmVjb3JkZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG5pbXBvcnQgeyBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ2ZzJztcbmltcG9ydCB7IGpvaW4sIGRpcm5hbWUgfSBmcm9tICdwYXRoJztcbmltcG9ydCB7IGV4ZWNTeW5jIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQge1xuICBUcmFuc2Zvcm1hdGlvbixcbiAgQ29uc2VxdWVuY2VSZWNvcmQsXG4gIE9ic2VydmF0aW9uRXZlbnQsXG4gIEd1YXJkcmFpbFJlc3VsdCxcbiAgQXJ0aWZhY3QsXG4gIFRvb2xDYWxsLFxuICBDb3JlUHJvdGVjdGlvblJlc3VsdCxcbiAgUmVjb3JkZXJDb25maWcsXG4gIFRyYW5zZm9ybWF0aW9uU2NoZW1hLFxuICBDb25zZXF1ZW5jZVJlY29yZFNjaGVtYSxcbiAgUmVjb3JkZXJDb25maWdTY2hlbWEsXG59IGZyb20gJy4uLy4uL3NyYy90eXBlcy9hZ2VudC1vYnNlcnZhYmlsaXR5JztcbmltcG9ydCB7IENvcmVQcm90ZWN0aW9uIH0gZnJvbSAnLi9Db3JlUHJvdGVjdGlvbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNmb3JtYXRpb25TaW5rIHtcbiAgd3JpdGUocmVjb3JkOiBDb25zZXF1ZW5jZVJlY29yZCk6IFByb21pc2U8dm9pZD47XG59XG5cbmV4cG9ydCBjbGFzcyBGaWxlU3lzdGVtU2luayBpbXBsZW1lbnRzIFRyYW5zZm9ybWF0aW9uU2luayB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgYmFzZVBhdGg6IHN0cmluZykge31cblxuICBhc3luYyB3cml0ZShyZWNvcmQ6IENvbnNlcXVlbmNlUmVjb3JkKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcGF0Y2hEaXIgPSBqb2luKHRoaXMuYmFzZVBhdGgsICdkb2NzJywgJ3BhdGNoZXMnLCBgcGF0Y2gtJHtyZWNvcmQudHJhbnNmb3JtYXRpb24ucGF0Y2hJZH1gKTtcbiAgICBcbiAgICAvLyBFbnN1cmUgZGlyZWN0b3J5IGV4aXN0c1xuICAgIGF3YWl0IGZzLm1rZGlyKHBhdGNoRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICBcbiAgICAvLyBXcml0ZSBKU09OTCBsZWRnZXIgZW50cnlcbiAgICBjb25zdCBsZWRnZXJQYXRoID0gam9pbihwYXRjaERpciwgJ2xlZGdlci5qc29ubCcpO1xuICAgIGNvbnN0IGxlZGdlckVudHJ5ID0gSlNPTi5zdHJpbmdpZnkocmVjb3JkKSArICdcXG4nO1xuICAgIGF3YWl0IGZzLmFwcGVuZEZpbGUobGVkZ2VyUGF0aCwgbGVkZ2VyRW50cnksICd1dGY4Jyk7XG4gICAgXG4gICAgLy8gV3JpdGUgaHVtYW4tcmVhZGFibGUgY29uc2VxdWVuY2VzXG4gICAgY29uc3QgY29uc2VxdWVuY2VzUGF0aCA9IGpvaW4ocGF0Y2hEaXIsICdDT05TRVFVRU5DRVMubWQnKTtcbiAgICBjb25zdCBtYXJrZG93biA9IHRoaXMuZ2VuZXJhdGVDb25zZXF1ZW5jZXNNYXJrZG93bihyZWNvcmQpO1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShjb25zZXF1ZW5jZXNQYXRoLCBtYXJrZG93biwgJ3V0ZjgnKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVDb25zZXF1ZW5jZXNNYXJrZG93bihyZWNvcmQ6IENvbnNlcXVlbmNlUmVjb3JkKTogc3RyaW5nIHtcbiAgICBjb25zdCB7IHRyYW5zZm9ybWF0aW9uLCBndWFyZHJhaWxzLCBzdW1tYXJ5LCBkZWNpc2lvbiwgY29yZUludGVncml0eVZlcmlmaWVkIH0gPSByZWNvcmQ7XG4gICAgXG4gICAgY29uc3QgcGFzc2VkR3VhcmRyYWlscyA9IGd1YXJkcmFpbHMuZmlsdGVyKGcgPT4gZy5zdGF0dXMgPT09ICdwYXNzJyk7XG4gICAgY29uc3QgZmFpbGVkR3VhcmRyYWlscyA9IGd1YXJkcmFpbHMuZmlsdGVyKGcgPT4gZy5zdGF0dXMgPT09ICdmYWlsJyk7XG4gICAgY29uc3Qgd2FybmluZ0d1YXJkcmFpbHMgPSBndWFyZHJhaWxzLmZpbHRlcihnID0+IGcuc3RhdHVzID09PSAnd2FybicpO1xuICAgIFxuICAgIHJldHVybiBgIyBUcmFuc2Zvcm1hdGlvbiBDb25zZXF1ZW5jZXMgLSBQYXRjaCAke3RyYW5zZm9ybWF0aW9uLnBhdGNoSWR9XG5cbioqVHJhbnNmb3JtYXRpb24gSUQqKjogXFxgJHt0cmFuc2Zvcm1hdGlvbi5pZH1cXGAgIFxuKipCcmFuY2gqKjogXFxgJHt0cmFuc2Zvcm1hdGlvbi5icmFuY2h9XFxgICBcbioqVGltZXN0YW1wKio6ICR7dHJhbnNmb3JtYXRpb24udGltZXN0YW1wfSAgXG4qKkNvcmUgSW50ZWdyaXR5Kio6ICR7Y29yZUludGVncml0eVZlcmlmaWVkID8gJ+KchSBWRVJJRklFRCcgOiAn4p2MIENPTVBST01JU0VEJ30gIFxuKipEZWNpc2lvbioqOiAqKiR7ZGVjaXNpb24udG9VcHBlckNhc2UoKX0qKlxuXG4jIyBTdW1tYXJ5XG5cbiR7c3VtbWFyeX1cblxuIyMgRmlsZXMgTW9kaWZpZWRcblxuJHt0cmFuc2Zvcm1hdGlvbi5maWxlc1RvdWNoZWQubWFwKGYgPT4gYC0gXFxgJHtmfVxcYGApLmpvaW4oJ1xcbicpfVxuXG4jIyBHaXQgU3RhdGlzdGljc1xuXG4tICoqQWRkaXRpb25zKio6ICR7dHJhbnNmb3JtYXRpb24uZ2l0U3RhdHMuYWRkaXRpb25zfVxuLSAqKkRlbGV0aW9ucyoqOiAke3RyYW5zZm9ybWF0aW9uLmdpdFN0YXRzLmRlbGV0aW9uc31cbi0gKipDaGFuZ2VkIEZpbGVzKio6ICR7dHJhbnNmb3JtYXRpb24uZ2l0U3RhdHMuY2hhbmdlZEZpbGVzfVxuLSAqKlNIQSoqOiBcXGAke3RyYW5zZm9ybWF0aW9uLmdpdFN0YXRzLnNoYX1cXGBcblxuIyMgQ29yZSBQcm90ZWN0aW9uIFN0YXR1c1xuXG4qKlN0YXR1cyoqOiBcXGAke3RyYW5zZm9ybWF0aW9uLmNvcmVQcm90ZWN0aW9uU3RhdHVzfVxcYFxuXG4ke3RyYW5zZm9ybWF0aW9uLmNvcmVQcm90ZWN0aW9uU3RhdHVzID09PSAndmlvbGF0aW9uX2RldGVjdGVkJyA/IFxuICAn4pqg77iPICoqV0FSTklORyoqOiBQcmlzdGluZSBjb3JlIHZpb2xhdGlvbiBkZXRlY3RlZCBidXQgYmxvY2tlZCBieSBwcm90ZWN0aW9uIG1lY2hhbmlzbXMuJyA6IFxuICB0cmFuc2Zvcm1hdGlvbi5jb3JlUHJvdGVjdGlvblN0YXR1cyA9PT0gJ3Zpb2xhdGlvbl9ibG9ja2VkJyA/XG4gICfwn5uRICoqQ1JJVElDQUwqKjogQXR0ZW1wdGVkIHByaXN0aW5lIGNvcmUgbW9kaWZpY2F0aW9uIHdhcyBibG9ja2VkLicgOlxuICAn4pyFIE5vIHByaXN0aW5lIGNvcmUgdmlvbGF0aW9ucyBkZXRlY3RlZC4nXG59XG5cbiMjIEd1YXJkcmFpbCBSZXN1bHRzXG5cbiMjIyDinIUgUGFzc2VkICgke3Bhc3NlZEd1YXJkcmFpbHMubGVuZ3RofSlcbiR7cGFzc2VkR3VhcmRyYWlscy5tYXAoZyA9PiBgLSAqKiR7Zy5uYW1lfSoqOiAke09iamVjdC5lbnRyaWVzKGcubWV0cmljcykubWFwKChbayx2XSkgPT4gYCR7a309JHt2fWApLmpvaW4oJywgJyl9YCkuam9pbignXFxuJyl9XG5cbiR7ZmFpbGVkR3VhcmRyYWlscy5sZW5ndGggPiAwID8gYCMjIyDinYwgRmFpbGVkICgke2ZhaWxlZEd1YXJkcmFpbHMubGVuZ3RofSlcbiR7ZmFpbGVkR3VhcmRyYWlscy5tYXAoZyA9PiBgLSAqKiR7Zy5uYW1lfSoqOiAke09iamVjdC5lbnRyaWVzKGcubWV0cmljcykubWFwKChbayx2XSkgPT4gYCR7a309JHt2fWApLmpvaW4oJywgJyl9YCkuam9pbignXFxuJyl9YCA6ICcnfVxuXG4ke3dhcm5pbmdHdWFyZHJhaWxzLmxlbmd0aCA+IDAgPyBgIyMjIOKaoO+4jyBXYXJuaW5ncyAoJHt3YXJuaW5nR3VhcmRyYWlscy5sZW5ndGh9KVxuJHt3YXJuaW5nR3VhcmRyYWlscy5tYXAoZyA9PiBgLSAqKiR7Zy5uYW1lfSoqOiAke09iamVjdC5lbnRyaWVzKGcubWV0cmljcykubWFwKChbayx2XSkgPT4gYCR7a309JHt2fWApLmpvaW4oJywgJyl9YCkuam9pbignXFxuJyl9YCA6ICcnfVxuXG4jIyBMZWFybmluZyBJbnNpZ2h0c1xuXG4ke3JlY29yZC5sZWFybmluZ0luc2lnaHRzPy5sZW5ndGggPyBcbiAgcmVjb3JkLmxlYXJuaW5nSW5zaWdodHMubWFwKGluc2lnaHQgPT4gYC0gJHtpbnNpZ2h0fWApLmpvaW4oJ1xcbicpIDogXG4gICdObyBhZGFwdGl2ZSBsZWFybmluZyBpbnNpZ2h0cyByZWNvcmRlZC4nXG59XG5cbi0tLVxuKkdlbmVyYXRlZCBieSBUcmFuc2Zvcm1hdGlvblJlY29yZGVyIHYke3JlY29yZC52ZXJzaW9ufSpcbmA7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFN1cGFiYXNlU2luayBpbXBsZW1lbnRzIFRyYW5zZm9ybWF0aW9uU2luayB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgc3VwYWJhc2VDbGllbnQ6IGFueSkge31cblxuICBhc3luYyB3cml0ZShyZWNvcmQ6IENvbnNlcXVlbmNlUmVjb3JkKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gVHJhbnNmb3JtIHRvIGRhdGFiYXNlIHNjaGVtYVxuICAgIGNvbnN0IHRyYW5zZm9ybWF0aW9uUm93ID0ge1xuICAgICAgaWQ6IHJlY29yZC50cmFuc2Zvcm1hdGlvbi5pZCxcbiAgICAgIHBhdGNoX2lkOiByZWNvcmQudHJhbnNmb3JtYXRpb24ucGF0Y2hJZCxcbiAgICAgIGJhdGNoX2lkOiByZWNvcmQudHJhbnNmb3JtYXRpb24uYmF0Y2hJZCB8fCBudWxsLFxuICAgICAgYnJhbmNoOiByZWNvcmQudHJhbnNmb3JtYXRpb24uYnJhbmNoLFxuICAgICAgYXV0aG9yX2lkOiByZWNvcmQudHJhbnNmb3JtYXRpb24uYXV0aG9ySWQsXG4gICAgICBjcmVhdGVkX2F0OiByZWNvcmQudHJhbnNmb3JtYXRpb24udGltZXN0YW1wLFxuICAgICAgY2F0ZWdvcmllczogcmVjb3JkLnRyYW5zZm9ybWF0aW9uLmNhdGVnb3JpZXMsXG4gICAgICBmaWxlc190b3VjaGVkOiByZWNvcmQudHJhbnNmb3JtYXRpb24uZmlsZXNUb3VjaGVkLFxuICAgICAgZ2l0X3N0YXRzOiByZWNvcmQudHJhbnNmb3JtYXRpb24uZ2l0U3RhdHMsXG4gICAgICBjb3JlX3Byb3RlY3Rpb25fc3RhdHVzOiByZWNvcmQudHJhbnNmb3JtYXRpb24uY29yZVByb3RlY3Rpb25TdGF0dXMsXG4gICAgICBzdW1tYXJ5OiByZWNvcmQuc3VtbWFyeSxcbiAgICAgIGRlY2lzaW9uOiByZWNvcmQuZGVjaXNpb24sXG4gICAgICBjb3JlX2ludGVncml0eV92ZXJpZmllZDogcmVjb3JkLmNvcmVJbnRlZ3JpdHlWZXJpZmllZCxcbiAgICB9O1xuXG4gICAgLy8gSW5zZXJ0IHRyYW5zZm9ybWF0aW9uXG4gICAgY29uc3QgeyBlcnJvcjogdHJhbnNmb3JtYXRpb25FcnJvciB9ID0gYXdhaXQgdGhpcy5zdXBhYmFzZUNsaWVudFxuICAgICAgLmZyb20oJ3RyYW5zZm9ybWF0aW9ucycpXG4gICAgICAuaW5zZXJ0KHRyYW5zZm9ybWF0aW9uUm93KTtcblxuICAgIGlmICh0cmFuc2Zvcm1hdGlvbkVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBpbnNlcnQgdHJhbnNmb3JtYXRpb246ICR7dHJhbnNmb3JtYXRpb25FcnJvci5tZXNzYWdlfWApO1xuICAgIH1cblxuICAgIC8vIEluc2VydCBndWFyZHJhaWxzXG4gICAgY29uc3QgZ3VhcmRyYWlsUm93cyA9IHJlY29yZC5ndWFyZHJhaWxzLm1hcChnID0+ICh7XG4gICAgICBpZDogYCR7cmVjb3JkLnRyYW5zZm9ybWF0aW9uLmlkfS0ke2cubmFtZX1gLFxuICAgICAgdHJhbnNmb3JtYXRpb25faWQ6IHJlY29yZC50cmFuc2Zvcm1hdGlvbi5pZCxcbiAgICAgIG5hbWU6IGcubmFtZSxcbiAgICAgIHN0YXR1czogZy5zdGF0dXMsXG4gICAgICBjcmVhdGVkX2F0OiBnLnRpbWVzdGFtcCxcbiAgICAgIGR1cmF0aW9uOiBnLmR1cmF0aW9uLFxuICAgICAgbWV0cmljczogZy5tZXRyaWNzLFxuICAgICAgZXhpdF9jb2RlOiBnLmV4aXRDb2RlIHx8IG51bGwsXG4gICAgfSkpO1xuXG4gICAgaWYgKGd1YXJkcmFpbFJvd3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgeyBlcnJvcjogZ3VhcmRyYWlsRXJyb3IgfSA9IGF3YWl0IHRoaXMuc3VwYWJhc2VDbGllbnRcbiAgICAgICAgLmZyb20oJ2d1YXJkcmFpbHMnKVxuICAgICAgICAuaW5zZXJ0KGd1YXJkcmFpbFJvd3MpO1xuXG4gICAgICBpZiAoZ3VhcmRyYWlsRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gaW5zZXJ0IGd1YXJkcmFpbHM6ICR7Z3VhcmRyYWlsRXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbnNlcnQgYXJ0aWZhY3RzXG4gICAgY29uc3QgYXJ0aWZhY3RSb3dzID0gcmVjb3JkLmFydGlmYWN0cy5tYXAoYSA9PiAoe1xuICAgICAgaWQ6IGEuaWQsXG4gICAgICB0cmFuc2Zvcm1hdGlvbl9pZDogcmVjb3JkLnRyYW5zZm9ybWF0aW9uLmlkLFxuICAgICAga2luZDogYS5raW5kLFxuICAgICAgcGF0aDogYS5wYXRoLFxuICAgICAgaGFzaDogYS5oYXNoIHx8IG51bGwsXG4gICAgICBzaXplOiBhLnNpemUgfHwgbnVsbCxcbiAgICAgIG1ldGFkYXRhOiBhLm1ldGFkYXRhIHx8IG51bGwsXG4gICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfSkpO1xuXG4gICAgaWYgKGFydGlmYWN0Um93cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB7IGVycm9yOiBhcnRpZmFjdEVycm9yIH0gPSBhd2FpdCB0aGlzLnN1cGFiYXNlQ2xpZW50XG4gICAgICAgIC5mcm9tKCdhcnRpZmFjdHMnKVxuICAgICAgICAuaW5zZXJ0KGFydGlmYWN0Um93cyk7XG5cbiAgICAgIGlmIChhcnRpZmFjdEVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGluc2VydCBhcnRpZmFjdHM6ICR7YXJ0aWZhY3RFcnJvci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVHJhbnNmb3JtYXRpb25SZWNvcmRlciB7XG4gIHByaXZhdGUgdHJhbnNmb3JtYXRpb246IFRyYW5zZm9ybWF0aW9uIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgZXZlbnRzOiBPYnNlcnZhdGlvbkV2ZW50W10gPSBbXTtcbiAgcHJpdmF0ZSBndWFyZHJhaWxzOiBHdWFyZHJhaWxSZXN1bHRbXSA9IFtdO1xuICBwcml2YXRlIGFydGlmYWN0czogQXJ0aWZhY3RbXSA9IFtdO1xuICBwcml2YXRlIHRvb2xDYWxsczogVG9vbENhbGxbXSA9IFtdO1xuICBwcml2YXRlIHNpbmtzOiBUcmFuc2Zvcm1hdGlvblNpbmtbXSA9IFtdO1xuICBwcml2YXRlIGNvcmVQcm90ZWN0aW9uOiBDb3JlUHJvdGVjdGlvbjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbmZpZzogUmVjb3JkZXJDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IFJlY29yZGVyQ29uZmlnU2NoZW1hLnBhcnNlKGNvbmZpZyk7XG4gICAgdGhpcy5jb3JlUHJvdGVjdGlvbiA9IG5ldyBDb3JlUHJvdGVjdGlvbihjb25maWcpO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgc2lua3NcbiAgICBpZiAoY29uZmlnLmVuYWJsZUZpbGVTeXN0ZW1TaW5rKSB7XG4gICAgICB0aGlzLnNpbmtzLnB1c2gobmV3IEZpbGVTeXN0ZW1TaW5rKHByb2Nlc3MuY3dkKCkpKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGNvbmZpZy5lbmFibGVTdXBhYmFzZVNpbmsgJiYgcHJvY2Vzcy5lbnYuU1VQQUJBU0VfQ0xJRU5UKSB7XG4gICAgICAvLyBOb3RlOiBTdXBhYmFzZSBjbGllbnQgd291bGQgYmUgaW5qZWN0ZWQgaW4gcmVhbCBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gdGhpcy5zaW5rcy5wdXNoKG5ldyBTdXBhYmFzZVNpbmsoc3VwYWJhc2VDbGllbnQpKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBzdGFydChjb250ZXh0OiB7XG4gICAgcGF0Y2hJZDogbnVtYmVyO1xuICAgIGJhdGNoSWQ/OiBudW1iZXI7XG4gICAgYnJhbmNoOiBzdHJpbmc7XG4gICAgYXV0aG9ySWQ6IHN0cmluZztcbiAgICBmaWxlc1RvdWNoZWQ6IHN0cmluZ1tdO1xuICB9KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAvLyBWYWxpZGF0ZSBjb3JlIHByb3RlY3Rpb24gQkVGT1JFIHN0YXJ0aW5nXG4gICAgY29uc3QgY29yZVByb3RlY3Rpb25SZXN1bHQgPSBhd2FpdCB0aGlzLmNvcmVQcm90ZWN0aW9uLnZhbGlkYXRlVHJhbnNmb3JtYXRpb24oY29udGV4dC5maWxlc1RvdWNoZWQpO1xuICAgIFxuICAgIGlmICghY29yZVByb3RlY3Rpb25SZXN1bHQuaXNWYWxpZCAmJiBjb3JlUHJvdGVjdGlvblJlc3VsdC52aW9sYXRpb25zLnNvbWUodiA9PiB2LnNldmVyaXR5ID09PSAnY3JpdGljYWwnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDUklUSUNBTDogUHJpc3RpbmUgY29yZSB2aW9sYXRpb24gZGV0ZWN0ZWQuIENhbm5vdCBwcm9jZWVkIHdpdGggdHJhbnNmb3JtYXRpb24uYCk7XG4gICAgfVxuXG4gICAgLy8gR2V0IGdpdCBpbmZvcm1hdGlvblxuICAgIGNvbnN0IGdpdFN0YXRzID0gdGhpcy5nZXRHaXRTdGF0cygpO1xuICAgIGNvbnN0IHRyYW5zZm9ybWF0aW9uSWQgPSBgcGF0Y2gtJHtjb250ZXh0LnBhdGNoSWR9QCR7Z2l0U3RhdHMuc2hhLnN1YnN0cmluZygwLCA3KX1gO1xuXG4gICAgdGhpcy50cmFuc2Zvcm1hdGlvbiA9IFRyYW5zZm9ybWF0aW9uU2NoZW1hLnBhcnNlKHtcbiAgICAgIGlkOiB0cmFuc2Zvcm1hdGlvbklkLFxuICAgICAgcGF0Y2hJZDogY29udGV4dC5wYXRjaElkLFxuICAgICAgYmF0Y2hJZDogY29udGV4dC5iYXRjaElkLFxuICAgICAgYnJhbmNoOiBjb250ZXh0LmJyYW5jaCxcbiAgICAgIGF1dGhvcklkOiBjb250ZXh0LmF1dGhvcklkLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBjYXRlZ29yaWVzOiB0aGlzLmNhdGVnb3JpemVGaWxlcyhjb250ZXh0LmZpbGVzVG91Y2hlZCksXG4gICAgICBmaWxlc1RvdWNoZWQ6IGNvbnRleHQuZmlsZXNUb3VjaGVkLFxuICAgICAgZ2l0U3RhdHMsXG4gICAgICBjb3JlUHJvdGVjdGlvblN0YXR1czogY29yZVByb3RlY3Rpb25SZXN1bHQuaXNWYWxpZCA/ICdzYWZlJyA6ICd2aW9sYXRpb25fZGV0ZWN0ZWQnLFxuICAgIH0pO1xuXG4gICAgLy8gUmVjb3JkIHN0YXJ0IGV2ZW50XG4gICAgYXdhaXQgdGhpcy5hdHRhY2hFdmVudCh7XG4gICAgICBuYW1lOiAndHJhbnNmb3JtYXRpb25fc3RhcnRlZCcsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHNldmVyaXR5OiAnaW5mbycsXG4gICAgICBwYXlsb2FkOiB7IHRyYW5zZm9ybWF0aW9uSWQsIGZpbGVzVG91Y2hlZDogY29udGV4dC5maWxlc1RvdWNoZWQgfSxcbiAgICAgIGNhdGVnb3J5OiAnc3lzdGVtJyxcbiAgICB9KTtcblxuICAgIHJldHVybiB0cmFuc2Zvcm1hdGlvbklkO1xuICB9XG5cbiAgYXN5bmMgYXR0YWNoRXZlbnQoZXZlbnQ6IE9ic2VydmF0aW9uRXZlbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLmV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgfVxuXG4gIGFzeW5jIGF0dGFjaEFydGlmYWN0KGFydGlmYWN0OiBBcnRpZmFjdCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuYXJ0aWZhY3RzLnB1c2goYXJ0aWZhY3QpO1xuICB9XG5cbiAgYXN5bmMgYXR0YWNoVG9vbENhbGwodG9vbENhbGw6IFRvb2xDYWxsKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gVmFsaWRhdGUgdG9vbCBjYWxsIGFnYWluc3QgY29yZSBwcm90ZWN0aW9uIGlmIGVuYWJsZWRcbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlQ29yZVByb3RlY3Rpb24gJiYgdG9vbENhbGwubmFtZSA9PT0gJ0VkaXQnKSB7XG4gICAgICBjb25zdCBmaWxlUGF0aCA9IHRvb2xDYWxsLnBhcmFtZXRlcnMuZmlsZV9wYXRoIGFzIHN0cmluZztcbiAgICAgIGlmIChmaWxlUGF0aCAmJiB0aGlzLmNvcmVQcm90ZWN0aW9uLmlzUHJpc3RpbmVDb3JlUGF0aChmaWxlUGF0aCkpIHtcbiAgICAgICAgdG9vbENhbGwuY29yZVByb3RlY3Rpb25DaGVjayA9IHRydWU7XG4gICAgICAgIGF3YWl0IHRoaXMuYXR0YWNoRXZlbnQoe1xuICAgICAgICAgIG5hbWU6ICdjb3JlX3Byb3RlY3Rpb25fdmlvbGF0aW9uJyxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBzZXZlcml0eTogJ2NyaXRpY2FsJyxcbiAgICAgICAgICBwYXlsb2FkOiB7IHRvb2xDYWxsOiB0b29sQ2FsbC5uYW1lLCBmaWxlUGF0aCB9LFxuICAgICAgICAgIGNhdGVnb3J5OiAnY29yZV9wcm90ZWN0aW9uJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHRoaXMudG9vbENhbGxzLnB1c2godG9vbENhbGwpO1xuICB9XG5cbiAgYXN5bmMgZmluYWxpemUoc3VtbWFyeTogc3RyaW5nLCBkZWNpc2lvbjogJ3Byb2NlZWQnIHwgJ2ZpeF9yZXF1aXJlZCcgfCAncm9sbGJhY2snIHwgJ21hbnVhbF9yZXZpZXcnKTogUHJvbWlzZTxDb25zZXF1ZW5jZVJlY29yZD4ge1xuICAgIGlmICghdGhpcy50cmFuc2Zvcm1hdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluYWxpemU6IHRyYW5zZm9ybWF0aW9uIG5vdCBzdGFydGVkJyk7XG4gICAgfVxuXG4gICAgLy8gUnVuIGFsbCBndWFyZHJhaWxzXG4gICAgYXdhaXQgdGhpcy5ydW5HdWFyZHJhaWxzKCk7XG5cbiAgICAvLyBGaW5hbCBjb3JlIGludGVncml0eSBjaGVja1xuICAgIGNvbnN0IGZpbmFsQ29yZUNoZWNrID0gYXdhaXQgdGhpcy5jb3JlUHJvdGVjdGlvbi5hdWRpdENvcmVJbnRlZ3JpdHkoKTtcbiAgICBjb25zdCBjb3JlSW50ZWdyaXR5VmVyaWZpZWQgPSBmaW5hbENvcmVDaGVjay5pc1ZhbGlkO1xuXG4gICAgLy8gR2VuZXJhdGUgbGVhcm5pbmcgaW5zaWdodHNcbiAgICBjb25zdCBsZWFybmluZ0luc2lnaHRzID0gdGhpcy5nZW5lcmF0ZUxlYXJuaW5nSW5zaWdodHMoKTtcblxuICAgIGNvbnN0IHJlY29yZDogQ29uc2VxdWVuY2VSZWNvcmQgPSBDb25zZXF1ZW5jZVJlY29yZFNjaGVtYS5wYXJzZSh7XG4gICAgICB0cmFuc2Zvcm1hdGlvbjogdGhpcy50cmFuc2Zvcm1hdGlvbixcbiAgICAgIGV2ZW50czogdGhpcy5ldmVudHMsXG4gICAgICBndWFyZHJhaWxzOiB0aGlzLmd1YXJkcmFpbHMsXG4gICAgICBhcnRpZmFjdHM6IHRoaXMuYXJ0aWZhY3RzLFxuICAgICAgdG9vbENhbGxzOiB0aGlzLnRvb2xDYWxscyxcbiAgICAgIHN1bW1hcnksXG4gICAgICBkZWNpc2lvbixcbiAgICAgIGNvcmVJbnRlZ3JpdHlWZXJpZmllZCxcbiAgICAgIGxlYXJuaW5nSW5zaWdodHMsXG4gICAgICByZWRhY3Rpb25zOiB0aGlzLmNvbmZpZy5yZWRhY3RQYXR0ZXJucyxcbiAgICAgIHZlcnNpb246ICcxLjAnLFxuICAgIH0pO1xuXG4gICAgLy8gV3JpdGUgdG8gYWxsIHNpbmtzXG4gICAgZm9yIChjb25zdCBzaW5rIG9mIHRoaXMuc2lua3MpIHtcbiAgICAgIGF3YWl0IHNpbmsud3JpdGUocmVjb3JkKTtcbiAgICB9XG5cbiAgICAvLyBSZWNvcmQgY29tcGxldGlvbiBldmVudFxuICAgIGF3YWl0IHRoaXMuYXR0YWNoRXZlbnQoe1xuICAgICAgbmFtZTogJ3RyYW5zZm9ybWF0aW9uX2NvbXBsZXRlZCcsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHNldmVyaXR5OiAnaW5mbycsXG4gICAgICBwYXlsb2FkOiB7IGRlY2lzaW9uLCBjb3JlSW50ZWdyaXR5VmVyaWZpZWQgfSxcbiAgICAgIGNhdGVnb3J5OiAnc3lzdGVtJyxcbiAgICB9KTtcblxuICAgIHJldHVybiByZWNvcmQ7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJ1bkd1YXJkcmFpbHMoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZ3VhcmRyYWlsUnVubmVycyA9IFtcbiAgICAgICgpID0+IHRoaXMucnVuVHlwZWNoZWNrKCksXG4gICAgICAoKSA9PiB0aGlzLnJ1bkxpbnQoKSxcbiAgICAgICgpID0+IHRoaXMucnVuVGVzdHMoKSxcbiAgICAgICgpID0+IHRoaXMucnVuQnVpbGQoKSxcbiAgICAgICgpID0+IHRoaXMucnVuQ29yZVByb3RlY3Rpb24oKSxcbiAgICBdO1xuXG4gICAgZm9yIChjb25zdCBydW5uZXIgb2YgZ3VhcmRyYWlsUnVubmVycykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcnVubmVyKCk7XG4gICAgICAgIHRoaXMuZ3VhcmRyYWlscy5wdXNoKHJlc3VsdCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBDb250aW51ZSB3aXRoIG90aGVyIGd1YXJkcmFpbHMgZXZlbiBpZiBvbmUgZmFpbHNcbiAgICAgICAgY29uc29sZS53YXJuKGBHdWFyZHJhaWwgZmFpbGVkOiAke2Vycm9yfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcnVuVHlwZWNoZWNrKCk6IFByb21pc2U8R3VhcmRyYWlsUmVzdWx0PiB7XG4gICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSBleGVjU3luYygncG5wbSB0eXBlY2hlY2snLCB7IGVuY29kaW5nOiAndXRmOCcsIHRpbWVvdXQ6IDMwMDAwIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ3R5cGVjaGVjaycsXG4gICAgICAgIHN0YXR1czogJ3Bhc3MnLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgZHVyYXRpb246IERhdGUubm93KCkgLSBzdGFydCxcbiAgICAgICAgbWV0cmljczogeyBlcnJvcnM6IDAgfSxcbiAgICAgICAgYXJ0aWZhY3RzOiBbXSxcbiAgICAgICAgZXhpdENvZGU6IDAsXG4gICAgICAgIHN0ZG91dDogb3V0cHV0LFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAndHlwZWNoZWNrJyxcbiAgICAgICAgc3RhdHVzOiAnZmFpbCcsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBkdXJhdGlvbjogRGF0ZS5ub3coKSAtIHN0YXJ0LFxuICAgICAgICBtZXRyaWNzOiB7IGVycm9yczogMSB9LFxuICAgICAgICBhcnRpZmFjdHM6IFtdLFxuICAgICAgICBleGl0Q29kZTogZXJyb3Iuc3RhdHVzIHx8IDEsXG4gICAgICAgIHN0ZGVycjogZXJyb3IubWVzc2FnZSxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBydW5MaW50KCk6IFByb21pc2U8R3VhcmRyYWlsUmVzdWx0PiB7XG4gICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSBleGVjU3luYygncG5wbSBsaW50JywgeyBlbmNvZGluZzogJ3V0ZjgnLCB0aW1lb3V0OiAzMDAwMCB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdsaW50JyxcbiAgICAgICAgc3RhdHVzOiAncGFzcycsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBkdXJhdGlvbjogRGF0ZS5ub3coKSAtIHN0YXJ0LFxuICAgICAgICBtZXRyaWNzOiB7IGVycm9yczogMCwgd2FybmluZ3M6IDAgfSxcbiAgICAgICAgYXJ0aWZhY3RzOiBbXSxcbiAgICAgICAgZXhpdENvZGU6IDAsXG4gICAgICAgIHN0ZG91dDogb3V0cHV0LFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnbGludCcsXG4gICAgICAgIHN0YXR1czogJ2ZhaWwnLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgZHVyYXRpb246IERhdGUubm93KCkgLSBzdGFydCxcbiAgICAgICAgbWV0cmljczogeyBlcnJvcnM6IDEgfSxcbiAgICAgICAgYXJ0aWZhY3RzOiBbXSxcbiAgICAgICAgZXhpdENvZGU6IGVycm9yLnN0YXR1cyB8fCAxLFxuICAgICAgICBzdGRlcnI6IGVycm9yLm1lc3NhZ2UsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcnVuVGVzdHMoKTogUHJvbWlzZTxHdWFyZHJhaWxSZXN1bHQ+IHtcbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGV4ZWNTeW5jKCdwbnBtIHRlc3QgLS1jb3ZlcmFnZSAtLXBhc3NXaXRoTm9UZXN0cycsIHsgZW5jb2Rpbmc6ICd1dGY4JywgdGltZW91dDogNjAwMDAgfSk7XG4gICAgICAvLyBQYXJzZSBjb3ZlcmFnZSBmcm9tIG91dHB1dCAoc2ltcGxpZmllZClcbiAgICAgIGNvbnN0IGNvdmVyYWdlTWF0Y2ggPSBvdXRwdXQubWF0Y2goL0FsbCBmaWxlc1tefF0qXFx8W158XSpcXHxbXnxdKlxcfFtefF0qXFx8W158XSooXFxkK1xcLj9cXGQqKS8pO1xuICAgICAgY29uc3QgY292ZXJhZ2UgPSBjb3ZlcmFnZU1hdGNoID8gcGFyc2VGbG9hdChjb3ZlcmFnZU1hdGNoWzFdKSA6IDA7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICd0ZXN0JyxcbiAgICAgICAgc3RhdHVzOiBjb3ZlcmFnZSA+PSA5MCA/ICdwYXNzJyA6ICd3YXJuJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGR1cmF0aW9uOiBEYXRlLm5vdygpIC0gc3RhcnQsXG4gICAgICAgIG1ldHJpY3M6IHsgY292ZXJhZ2UsIHBhc3NlZDogMSwgZmFpbGVkOiAwIH0sXG4gICAgICAgIGFydGlmYWN0czogWydjb3ZlcmFnZS9sY292LXJlcG9ydC9pbmRleC5odG1sJ10sXG4gICAgICAgIGV4aXRDb2RlOiAwLFxuICAgICAgICBzdGRvdXQ6IG91dHB1dCxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ3Rlc3QnLFxuICAgICAgICBzdGF0dXM6ICdmYWlsJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGR1cmF0aW9uOiBEYXRlLm5vdygpIC0gc3RhcnQsXG4gICAgICAgIG1ldHJpY3M6IHsgY292ZXJhZ2U6IDAsIHBhc3NlZDogMCwgZmFpbGVkOiAxIH0sXG4gICAgICAgIGFydGlmYWN0czogW10sXG4gICAgICAgIGV4aXRDb2RlOiBlcnJvci5zdGF0dXMgfHwgMSxcbiAgICAgICAgc3RkZXJyOiBlcnJvci5tZXNzYWdlLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJ1bkJ1aWxkKCk6IFByb21pc2U8R3VhcmRyYWlsUmVzdWx0PiB7XG4gICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSBleGVjU3luYygncG5wbSBidWlsZCcsIHsgZW5jb2Rpbmc6ICd1dGY4JywgdGltZW91dDogMTIwMDAwIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ2J1aWxkJyxcbiAgICAgICAgc3RhdHVzOiAncGFzcycsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBkdXJhdGlvbjogRGF0ZS5ub3coKSAtIHN0YXJ0LFxuICAgICAgICBtZXRyaWNzOiB7IHN1Y2Nlc3M6IHRydWUgfSxcbiAgICAgICAgYXJ0aWZhY3RzOiBbJy5uZXh0L2J1aWxkLW1hbmlmZXN0Lmpzb24nXSxcbiAgICAgICAgZXhpdENvZGU6IDAsXG4gICAgICAgIHN0ZG91dDogb3V0cHV0LFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnYnVpbGQnLFxuICAgICAgICBzdGF0dXM6ICdmYWlsJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGR1cmF0aW9uOiBEYXRlLm5vdygpIC0gc3RhcnQsXG4gICAgICAgIG1ldHJpY3M6IHsgc3VjY2VzczogZmFsc2UgfSxcbiAgICAgICAgYXJ0aWZhY3RzOiBbXSxcbiAgICAgICAgZXhpdENvZGU6IGVycm9yLnN0YXR1cyB8fCAxLFxuICAgICAgICBzdGRlcnI6IGVycm9yLm1lc3NhZ2UsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcnVuQ29yZVByb3RlY3Rpb24oKTogUHJvbWlzZTxHdWFyZHJhaWxSZXN1bHQ+IHtcbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jb3JlUHJvdGVjdGlvbi5hdWRpdENvcmVJbnRlZ3JpdHkoKTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJ2NvcmVfcHJvdGVjdGlvbicsXG4gICAgICBzdGF0dXM6IHJlc3VsdC5pc1ZhbGlkID8gJ3Bhc3MnIDogJ2ZhaWwnLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBkdXJhdGlvbjogRGF0ZS5ub3coKSAtIHN0YXJ0LFxuICAgICAgbWV0cmljczogeyBcbiAgICAgICAgdmlvbGF0aW9uczogcmVzdWx0LnZpb2xhdGlvbnMubGVuZ3RoLFxuICAgICAgICBwcm90ZWN0ZWRQYXRoczogcmVzdWx0LnByb3RlY3RlZFBhdGhzLmxlbmd0aCxcbiAgICAgICAgYWxsb3dlZFBhdGhzOiByZXN1bHQuYWxsb3dlZFBhdGhzLmxlbmd0aCxcbiAgICAgIH0sXG4gICAgICBhcnRpZmFjdHM6IFtdLFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGdldEdpdFN0YXRzKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzaGEgPSBleGVjU3luYygnZ2l0IHJldi1wYXJzZSBIRUFEJywgeyBlbmNvZGluZzogJ3V0ZjgnIH0pLnRyaW0oKTtcbiAgICAgIGNvbnN0IHN0YXRzID0gZXhlY1N5bmMoJ2dpdCBkaWZmIC0tc3RhdCBIRUFEfjEnLCB7IGVuY29kaW5nOiAndXRmOCcgfSk7XG4gICAgICBcbiAgICAgIC8vIFBhcnNlIGdpdCBkaWZmIHN0YXRzIChzaW1wbGlmaWVkKVxuICAgICAgY29uc3QgbGluZXMgPSBzdGF0cy5zcGxpdCgnXFxuJyk7XG4gICAgICBjb25zdCBzdW1tYXJ5TGluZSA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDJdIHx8ICcnO1xuICAgICAgY29uc3QgbWF0Y2ggPSBzdW1tYXJ5TGluZS5tYXRjaCgvKFxcZCspIGZpbGVzPyBjaGFuZ2VkKD86LCAoXFxkKykgaW5zZXJ0aW9ucz8pPyg/OiwgKFxcZCspIGRlbGV0aW9ucz8pPy8pO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaGEsXG4gICAgICAgIGFkZGl0aW9uczogbWF0Y2ggPyBwYXJzZUludChtYXRjaFsyXSB8fCAnMCcpIDogMCxcbiAgICAgICAgZGVsZXRpb25zOiBtYXRjaCA/IHBhcnNlSW50KG1hdGNoWzNdIHx8ICcwJykgOiAwLFxuICAgICAgICBjaGFuZ2VkRmlsZXM6IG1hdGNoID8gcGFyc2VJbnQobWF0Y2hbMV0pIDogMCxcbiAgICAgIH07XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzaGE6ICd1bmtub3duJyxcbiAgICAgICAgYWRkaXRpb25zOiAwLFxuICAgICAgICBkZWxldGlvbnM6IDAsXG4gICAgICAgIGNoYW5nZWRGaWxlczogMCxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjYXRlZ29yaXplRmlsZXMoZmlsZXM6IHN0cmluZ1tdKTogQXJyYXk8J2NvZGUnIHwgJ2NvbmZpZycgfCAnZGF0YWJhc2UnIHwgJ2luZnJhc3RydWN0dXJlJyB8ICdkb2NzJz4ge1xuICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBuZXcgU2V0PCdjb2RlJyB8ICdjb25maWcnIHwgJ2RhdGFiYXNlJyB8ICdpbmZyYXN0cnVjdHVyZScgfCAnZG9jcyc+KCk7XG4gICAgXG4gICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICBpZiAoZmlsZS5tYXRjaCgvXFwuKHRzfHRzeHxqc3xqc3gpJC8pKSBjYXRlZ29yaWVzLmFkZCgnY29kZScpO1xuICAgICAgaWYgKGZpbGUubWF0Y2goL1xcLihqc29ufHlhbWx8eW1sfGVudnxjb25maWcpJC8pKSBjYXRlZ29yaWVzLmFkZCgnY29uZmlnJyk7XG4gICAgICBpZiAoZmlsZS5tYXRjaCgvcHJpc21hfG1pZ3JhdGlvbnN8XFwuc3FsJC8pKSBjYXRlZ29yaWVzLmFkZCgnZGF0YWJhc2UnKTtcbiAgICAgIGlmIChmaWxlLm1hdGNoKC9cXC5naXRodWJ8ZG9ja2VyfHZlcmNlbHxcXC5jb25maWdcXC4vKSkgY2F0ZWdvcmllcy5hZGQoJ2luZnJhc3RydWN0dXJlJyk7XG4gICAgICBpZiAoZmlsZS5tYXRjaCgvXFwubWQkfGRvY3NcXC8vKSkgY2F0ZWdvcmllcy5hZGQoJ2RvY3MnKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIEFycmF5LmZyb20oY2F0ZWdvcmllcyk7XG4gIH1cblxuICBwcml2YXRlIGdlbmVyYXRlTGVhcm5pbmdJbnNpZ2h0cygpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgaW5zaWdodHM6IHN0cmluZ1tdID0gW107XG4gICAgXG4gICAgLy8gQW5hbHl6ZSBndWFyZHJhaWwgcGF0dGVybnNcbiAgICBjb25zdCBmYWlsZWRHdWFyZHJhaWxzID0gdGhpcy5ndWFyZHJhaWxzLmZpbHRlcihnID0+IGcuc3RhdHVzID09PSAnZmFpbCcpO1xuICAgIGlmIChmYWlsZWRHdWFyZHJhaWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIGluc2lnaHRzLnB1c2goYEZhaWxlZCBndWFyZHJhaWxzOiAke2ZhaWxlZEd1YXJkcmFpbHMubWFwKGcgPT4gZy5uYW1lKS5qb2luKCcsICcpfWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBBbmFseXplIGZpbGUgcGF0dGVybnNcbiAgICBpZiAodGhpcy50cmFuc2Zvcm1hdGlvbikge1xuICAgICAgY29uc3QgZmlsZVR5cGVzID0gdGhpcy50cmFuc2Zvcm1hdGlvbi5maWxlc1RvdWNoZWQubWFwKGYgPT4gZi5zcGxpdCgnLicpLnBvcCgpKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICBjb25zdCB1bmlxdWVUeXBlcyA9IFsuLi5uZXcgU2V0KGZpbGVUeXBlcyldO1xuICAgICAgaW5zaWdodHMucHVzaChgRmlsZSB0eXBlcyBtb2RpZmllZDogJHt1bmlxdWVUeXBlcy5qb2luKCcsICcpfWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBBbmFseXplIHRvb2wgdXNhZ2VcbiAgICBjb25zdCB0b29sTmFtZXMgPSBbLi4ubmV3IFNldCh0aGlzLnRvb2xDYWxscy5tYXAodCA9PiB0Lm5hbWUpKV07XG4gICAgaWYgKHRvb2xOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICBpbnNpZ2h0cy5wdXNoKGBUb29scyB1c2VkOiAke3Rvb2xOYW1lcy5qb2luKCcsICcpfWApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gaW5zaWdodHM7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJGaWxlU3lzdGVtU2luayIsIlN1cGFiYXNlU2luayIsIlRyYW5zZm9ybWF0aW9uUmVjb3JkZXIiLCJjb25zdHJ1Y3RvciIsImJhc2VQYXRoIiwid3JpdGUiLCJyZWNvcmQiLCJwYXRjaERpciIsImpvaW4iLCJ0cmFuc2Zvcm1hdGlvbiIsInBhdGNoSWQiLCJmcyIsIm1rZGlyIiwicmVjdXJzaXZlIiwibGVkZ2VyUGF0aCIsImxlZGdlckVudHJ5IiwiSlNPTiIsInN0cmluZ2lmeSIsImFwcGVuZEZpbGUiLCJjb25zZXF1ZW5jZXNQYXRoIiwibWFya2Rvd24iLCJnZW5lcmF0ZUNvbnNlcXVlbmNlc01hcmtkb3duIiwid3JpdGVGaWxlIiwiZ3VhcmRyYWlscyIsInN1bW1hcnkiLCJkZWNpc2lvbiIsImNvcmVJbnRlZ3JpdHlWZXJpZmllZCIsInBhc3NlZEd1YXJkcmFpbHMiLCJmaWx0ZXIiLCJnIiwic3RhdHVzIiwiZmFpbGVkR3VhcmRyYWlscyIsIndhcm5pbmdHdWFyZHJhaWxzIiwiaWQiLCJicmFuY2giLCJ0aW1lc3RhbXAiLCJ0b1VwcGVyQ2FzZSIsImZpbGVzVG91Y2hlZCIsIm1hcCIsImYiLCJnaXRTdGF0cyIsImFkZGl0aW9ucyIsImRlbGV0aW9ucyIsImNoYW5nZWRGaWxlcyIsInNoYSIsImNvcmVQcm90ZWN0aW9uU3RhdHVzIiwibGVuZ3RoIiwibmFtZSIsIk9iamVjdCIsImVudHJpZXMiLCJtZXRyaWNzIiwiayIsInYiLCJsZWFybmluZ0luc2lnaHRzIiwiaW5zaWdodCIsInZlcnNpb24iLCJzdXBhYmFzZUNsaWVudCIsInRyYW5zZm9ybWF0aW9uUm93IiwicGF0Y2hfaWQiLCJiYXRjaF9pZCIsImJhdGNoSWQiLCJhdXRob3JfaWQiLCJhdXRob3JJZCIsImNyZWF0ZWRfYXQiLCJjYXRlZ29yaWVzIiwiZmlsZXNfdG91Y2hlZCIsImdpdF9zdGF0cyIsImNvcmVfcHJvdGVjdGlvbl9zdGF0dXMiLCJjb3JlX2ludGVncml0eV92ZXJpZmllZCIsImVycm9yIiwidHJhbnNmb3JtYXRpb25FcnJvciIsImZyb20iLCJpbnNlcnQiLCJFcnJvciIsIm1lc3NhZ2UiLCJndWFyZHJhaWxSb3dzIiwidHJhbnNmb3JtYXRpb25faWQiLCJkdXJhdGlvbiIsImV4aXRfY29kZSIsImV4aXRDb2RlIiwiZ3VhcmRyYWlsRXJyb3IiLCJhcnRpZmFjdFJvd3MiLCJhcnRpZmFjdHMiLCJhIiwia2luZCIsInBhdGgiLCJoYXNoIiwic2l6ZSIsIm1ldGFkYXRhIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiYXJ0aWZhY3RFcnJvciIsImNvbmZpZyIsImV2ZW50cyIsInRvb2xDYWxscyIsInNpbmtzIiwiUmVjb3JkZXJDb25maWdTY2hlbWEiLCJwYXJzZSIsImNvcmVQcm90ZWN0aW9uIiwiQ29yZVByb3RlY3Rpb24iLCJlbmFibGVGaWxlU3lzdGVtU2luayIsInB1c2giLCJwcm9jZXNzIiwiY3dkIiwiZW5hYmxlU3VwYWJhc2VTaW5rIiwiZW52IiwiU1VQQUJBU0VfQ0xJRU5UIiwic3RhcnQiLCJjb250ZXh0IiwiY29yZVByb3RlY3Rpb25SZXN1bHQiLCJ2YWxpZGF0ZVRyYW5zZm9ybWF0aW9uIiwiaXNWYWxpZCIsInZpb2xhdGlvbnMiLCJzb21lIiwic2V2ZXJpdHkiLCJnZXRHaXRTdGF0cyIsInRyYW5zZm9ybWF0aW9uSWQiLCJzdWJzdHJpbmciLCJUcmFuc2Zvcm1hdGlvblNjaGVtYSIsImNhdGVnb3JpemVGaWxlcyIsImF0dGFjaEV2ZW50IiwicGF5bG9hZCIsImNhdGVnb3J5IiwiZXZlbnQiLCJhdHRhY2hBcnRpZmFjdCIsImFydGlmYWN0IiwiYXR0YWNoVG9vbENhbGwiLCJ0b29sQ2FsbCIsImVuYWJsZUNvcmVQcm90ZWN0aW9uIiwiZmlsZVBhdGgiLCJwYXJhbWV0ZXJzIiwiZmlsZV9wYXRoIiwiaXNQcmlzdGluZUNvcmVQYXRoIiwiY29yZVByb3RlY3Rpb25DaGVjayIsImZpbmFsaXplIiwicnVuR3VhcmRyYWlscyIsImZpbmFsQ29yZUNoZWNrIiwiYXVkaXRDb3JlSW50ZWdyaXR5IiwiZ2VuZXJhdGVMZWFybmluZ0luc2lnaHRzIiwiQ29uc2VxdWVuY2VSZWNvcmRTY2hlbWEiLCJyZWRhY3Rpb25zIiwicmVkYWN0UGF0dGVybnMiLCJzaW5rIiwiZ3VhcmRyYWlsUnVubmVycyIsInJ1blR5cGVjaGVjayIsInJ1bkxpbnQiLCJydW5UZXN0cyIsInJ1bkJ1aWxkIiwicnVuQ29yZVByb3RlY3Rpb24iLCJydW5uZXIiLCJyZXN1bHQiLCJjb25zb2xlIiwid2FybiIsIm5vdyIsIm91dHB1dCIsImV4ZWNTeW5jIiwiZW5jb2RpbmciLCJ0aW1lb3V0IiwiZXJyb3JzIiwic3Rkb3V0Iiwic3RkZXJyIiwid2FybmluZ3MiLCJjb3ZlcmFnZU1hdGNoIiwibWF0Y2giLCJjb3ZlcmFnZSIsInBhcnNlRmxvYXQiLCJwYXNzZWQiLCJmYWlsZWQiLCJzdWNjZXNzIiwicHJvdGVjdGVkUGF0aHMiLCJhbGxvd2VkUGF0aHMiLCJ0cmltIiwic3RhdHMiLCJsaW5lcyIsInNwbGl0Iiwic3VtbWFyeUxpbmUiLCJwYXJzZUludCIsImZpbGVzIiwiU2V0IiwiZmlsZSIsImFkZCIsIkFycmF5IiwiaW5zaWdodHMiLCJmaWxlVHlwZXMiLCJwb3AiLCJCb29sZWFuIiwidW5pcXVlVHlwZXMiLCJ0b29sTmFtZXMiLCJ0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztJQXVC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